schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false

  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [String!]

  """does the array contain the given value"""
  _contains: [String!]
  _eq: [String!]
  _gt: [String!]
  _gte: [String!]
  _in: [[String!]!]
  _is_null: Boolean
  _lt: [String!]
  _lte: [String!]
  _neq: [String!]
  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""Scalar _Any"""
scalar _Any

"""A union of all types that use the @key directive"""
union _Entity = adjustment_rules | client_external_systems | clients | external_systems | holidays | leave | notes | payroll_cycles | payroll_date_types | payroll_dates | payrolls | users | work_schedule

type _Service {
  """SDL representation of schema"""
  sdl: String!
}

"""
columns and relationships of "adjustment_rules"
"""
type adjustment_rules {
  """Timestamp when the rule was created"""
  created_at: timestamptz

  """Reference to the payroll cycle this rule applies to"""
  cycle_id: uuid!

  """Reference to the payroll date type this rule affects"""
  date_type_id: uuid!

  """Unique identifier for the adjustment rule"""
  id: uuid!

  """An object relationship"""
  payroll_cycle: payroll_cycles!

  """An object relationship"""
  payroll_date_type: payroll_date_types!

  """Code/formula used to calculate date adjustments"""
  rule_code: String!

  """Human-readable description of the adjustment rule"""
  rule_description: String!

  """Timestamp when the rule was last updated"""
  updated_at: timestamptz
}

"""
aggregated selection of "adjustment_rules"
"""
type adjustment_rules_aggregate {
  aggregate: adjustment_rules_aggregate_fields
  nodes: [adjustment_rules!]!
}

input adjustment_rules_aggregate_bool_exp {
  count: adjustment_rules_aggregate_bool_exp_count
}

input adjustment_rules_aggregate_bool_exp_count {
  arguments: [adjustment_rules_select_column!]
  distinct: Boolean
  filter: adjustment_rules_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "adjustment_rules"
"""
type adjustment_rules_aggregate_fields {
  count(columns: [adjustment_rules_select_column!], distinct: Boolean): Int!
  max: adjustment_rules_max_fields
  min: adjustment_rules_min_fields
}

"""
order by aggregate values of table "adjustment_rules"
"""
input adjustment_rules_aggregate_order_by {
  count: order_by
  max: adjustment_rules_max_order_by
  min: adjustment_rules_min_order_by
}

"""
input type for inserting array relation for remote table "adjustment_rules"
"""
input adjustment_rules_arr_rel_insert_input {
  data: [adjustment_rules_insert_input!]!

  """upsert condition"""
  on_conflict: adjustment_rules_on_conflict
}

"""
Boolean expression to filter rows from the table "adjustment_rules". All fields are combined with a logical 'AND'.
"""
input adjustment_rules_bool_exp {
  _and: [adjustment_rules_bool_exp!]
  _not: adjustment_rules_bool_exp
  _or: [adjustment_rules_bool_exp!]
  created_at: timestamptz_comparison_exp
  cycle_id: uuid_comparison_exp
  date_type_id: uuid_comparison_exp
  id: uuid_comparison_exp
  payroll_cycle: payroll_cycles_bool_exp
  payroll_date_type: payroll_date_types_bool_exp
  rule_code: String_comparison_exp
  rule_description: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "adjustment_rules"
"""
enum adjustment_rules_constraint {
  """
  unique or primary key constraint on columns "date_type_id", "cycle_id"
  """
  adjustment_rules_cycle_id_date_type_id_key

  """
  unique or primary key constraint on columns "id"
  """
  adjustment_rules_pkey
}

"""
input type for inserting data into table "adjustment_rules"
"""
input adjustment_rules_insert_input {
  """Timestamp when the rule was created"""
  created_at: timestamptz

  """Reference to the payroll cycle this rule applies to"""
  cycle_id: uuid

  """Reference to the payroll date type this rule affects"""
  date_type_id: uuid

  """Unique identifier for the adjustment rule"""
  id: uuid
  payroll_cycle: payroll_cycles_obj_rel_insert_input
  payroll_date_type: payroll_date_types_obj_rel_insert_input

  """Code/formula used to calculate date adjustments"""
  rule_code: String

  """Human-readable description of the adjustment rule"""
  rule_description: String

  """Timestamp when the rule was last updated"""
  updated_at: timestamptz
}

"""aggregate max on columns"""
type adjustment_rules_max_fields {
  """Timestamp when the rule was created"""
  created_at: timestamptz

  """Reference to the payroll cycle this rule applies to"""
  cycle_id: uuid

  """Reference to the payroll date type this rule affects"""
  date_type_id: uuid

  """Unique identifier for the adjustment rule"""
  id: uuid

  """Code/formula used to calculate date adjustments"""
  rule_code: String

  """Human-readable description of the adjustment rule"""
  rule_description: String

  """Timestamp when the rule was last updated"""
  updated_at: timestamptz
}

"""
order by max() on columns of table "adjustment_rules"
"""
input adjustment_rules_max_order_by {
  """Timestamp when the rule was created"""
  created_at: order_by

  """Reference to the payroll cycle this rule applies to"""
  cycle_id: order_by

  """Reference to the payroll date type this rule affects"""
  date_type_id: order_by

  """Unique identifier for the adjustment rule"""
  id: order_by

  """Code/formula used to calculate date adjustments"""
  rule_code: order_by

  """Human-readable description of the adjustment rule"""
  rule_description: order_by

  """Timestamp when the rule was last updated"""
  updated_at: order_by
}

"""aggregate min on columns"""
type adjustment_rules_min_fields {
  """Timestamp when the rule was created"""
  created_at: timestamptz

  """Reference to the payroll cycle this rule applies to"""
  cycle_id: uuid

  """Reference to the payroll date type this rule affects"""
  date_type_id: uuid

  """Unique identifier for the adjustment rule"""
  id: uuid

  """Code/formula used to calculate date adjustments"""
  rule_code: String

  """Human-readable description of the adjustment rule"""
  rule_description: String

  """Timestamp when the rule was last updated"""
  updated_at: timestamptz
}

"""
order by min() on columns of table "adjustment_rules"
"""
input adjustment_rules_min_order_by {
  """Timestamp when the rule was created"""
  created_at: order_by

  """Reference to the payroll cycle this rule applies to"""
  cycle_id: order_by

  """Reference to the payroll date type this rule affects"""
  date_type_id: order_by

  """Unique identifier for the adjustment rule"""
  id: order_by

  """Code/formula used to calculate date adjustments"""
  rule_code: order_by

  """Human-readable description of the adjustment rule"""
  rule_description: order_by

  """Timestamp when the rule was last updated"""
  updated_at: order_by
}

"""
response of any mutation on the table "adjustment_rules"
"""
type adjustment_rules_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [adjustment_rules!]!
}

"""
on_conflict condition type for table "adjustment_rules"
"""
input adjustment_rules_on_conflict {
  constraint: adjustment_rules_constraint!
  update_columns: [adjustment_rules_update_column!]! = []
  where: adjustment_rules_bool_exp
}

"""Ordering options when selecting data from "adjustment_rules"."""
input adjustment_rules_order_by {
  created_at: order_by
  cycle_id: order_by
  date_type_id: order_by
  id: order_by
  payroll_cycle: payroll_cycles_order_by
  payroll_date_type: payroll_date_types_order_by
  rule_code: order_by
  rule_description: order_by
  updated_at: order_by
}

"""primary key columns input for table: adjustment_rules"""
input adjustment_rules_pk_columns_input {
  """Unique identifier for the adjustment rule"""
  id: uuid!
}

"""
select columns of table "adjustment_rules"
"""
enum adjustment_rules_select_column {
  """column name"""
  created_at

  """column name"""
  cycle_id

  """column name"""
  date_type_id

  """column name"""
  id

  """column name"""
  rule_code

  """column name"""
  rule_description

  """column name"""
  updated_at
}

"""
input type for updating data in table "adjustment_rules"
"""
input adjustment_rules_set_input {
  """Timestamp when the rule was created"""
  created_at: timestamptz

  """Reference to the payroll cycle this rule applies to"""
  cycle_id: uuid

  """Reference to the payroll date type this rule affects"""
  date_type_id: uuid

  """Unique identifier for the adjustment rule"""
  id: uuid

  """Code/formula used to calculate date adjustments"""
  rule_code: String

  """Human-readable description of the adjustment rule"""
  rule_description: String

  """Timestamp when the rule was last updated"""
  updated_at: timestamptz
}

"""
Streaming cursor of the table "adjustment_rules"
"""
input adjustment_rules_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: adjustment_rules_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input adjustment_rules_stream_cursor_value_input {
  """Timestamp when the rule was created"""
  created_at: timestamptz

  """Reference to the payroll cycle this rule applies to"""
  cycle_id: uuid

  """Reference to the payroll date type this rule affects"""
  date_type_id: uuid

  """Unique identifier for the adjustment rule"""
  id: uuid

  """Code/formula used to calculate date adjustments"""
  rule_code: String

  """Human-readable description of the adjustment rule"""
  rule_description: String

  """Timestamp when the rule was last updated"""
  updated_at: timestamptz
}

"""
update columns of table "adjustment_rules"
"""
enum adjustment_rules_update_column {
  """column name"""
  created_at

  """column name"""
  cycle_id

  """column name"""
  date_type_id

  """column name"""
  id

  """column name"""
  rule_code

  """column name"""
  rule_description

  """column name"""
  updated_at
}

input adjustment_rules_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: adjustment_rules_set_input

  """filter the rows which have to be updated"""
  where: adjustment_rules_bool_exp!
}

"""
columns and relationships of "app_settings"
"""
type app_settings {
  """Unique identifier for application setting"""
  id: String!

  """JSON structure containing application permission configurations"""
  permissions(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "app_settings"
"""
type app_settings_aggregate {
  aggregate: app_settings_aggregate_fields
  nodes: [app_settings!]!
}

"""
aggregate fields of "app_settings"
"""
type app_settings_aggregate_fields {
  count(columns: [app_settings_select_column!], distinct: Boolean): Int!
  max: app_settings_max_fields
  min: app_settings_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input app_settings_append_input {
  """JSON structure containing application permission configurations"""
  permissions: jsonb
}

"""
Boolean expression to filter rows from the table "app_settings". All fields are combined with a logical 'AND'.
"""
input app_settings_bool_exp {
  _and: [app_settings_bool_exp!]
  _not: app_settings_bool_exp
  _or: [app_settings_bool_exp!]
  id: String_comparison_exp
  permissions: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "app_settings"
"""
enum app_settings_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  app_settings_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input app_settings_delete_at_path_input {
  """JSON structure containing application permission configurations"""
  permissions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input app_settings_delete_elem_input {
  """JSON structure containing application permission configurations"""
  permissions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input app_settings_delete_key_input {
  """JSON structure containing application permission configurations"""
  permissions: String
}

"""
input type for inserting data into table "app_settings"
"""
input app_settings_insert_input {
  """Unique identifier for application setting"""
  id: String

  """JSON structure containing application permission configurations"""
  permissions: jsonb
}

"""aggregate max on columns"""
type app_settings_max_fields {
  """Unique identifier for application setting"""
  id: String
}

"""aggregate min on columns"""
type app_settings_min_fields {
  """Unique identifier for application setting"""
  id: String
}

"""
response of any mutation on the table "app_settings"
"""
type app_settings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [app_settings!]!
}

"""
on_conflict condition type for table "app_settings"
"""
input app_settings_on_conflict {
  constraint: app_settings_constraint!
  update_columns: [app_settings_update_column!]! = []
  where: app_settings_bool_exp
}

"""Ordering options when selecting data from "app_settings"."""
input app_settings_order_by {
  id: order_by
  permissions: order_by
}

"""primary key columns input for table: app_settings"""
input app_settings_pk_columns_input {
  """Unique identifier for application setting"""
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input app_settings_prepend_input {
  """JSON structure containing application permission configurations"""
  permissions: jsonb
}

"""
select columns of table "app_settings"
"""
enum app_settings_select_column {
  """column name"""
  id

  """column name"""
  permissions
}

"""
input type for updating data in table "app_settings"
"""
input app_settings_set_input {
  """Unique identifier for application setting"""
  id: String

  """JSON structure containing application permission configurations"""
  permissions: jsonb
}

"""
Streaming cursor of the table "app_settings"
"""
input app_settings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: app_settings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input app_settings_stream_cursor_value_input {
  """Unique identifier for application setting"""
  id: String

  """JSON structure containing application permission configurations"""
  permissions: jsonb
}

"""
update columns of table "app_settings"
"""
enum app_settings_update_column {
  """column name"""
  id

  """column name"""
  permissions
}

input app_settings_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: app_settings_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: app_settings_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: app_settings_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: app_settings_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: app_settings_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: app_settings_set_input

  """filter the rows which have to be updated"""
  where: app_settings_bool_exp!
}

scalar bpchar

"""
Boolean expression to compare columns of type "bpchar". All fields are combined with logical 'AND'.
"""
input bpchar_comparison_exp {
  _eq: bpchar
  _gt: bpchar
  _gte: bpchar

  """does the column match the given case-insensitive pattern"""
  _ilike: bpchar
  _in: [bpchar!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: bpchar
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: bpchar
  _lt: bpchar
  _lte: bpchar
  _neq: bpchar

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: bpchar
  _nin: [bpchar!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: bpchar

  """does the column NOT match the given pattern"""
  _nlike: bpchar

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: bpchar

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: bpchar

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: bpchar

  """does the column match the given SQL regular expression"""
  _similar: bpchar
}

"""
columns and relationships of "client_external_systems"
"""
type client_external_systems {
  """An object relationship"""
  client: clients!

  """Reference to the client"""
  client_id: uuid!

  """Timestamp when the mapping was created"""
  created_at: timestamptz

  """An object relationship"""
  external_system: external_systems!

  """Unique identifier for the client-system mapping"""
  id: uuid!

  """Client identifier in the external system"""
  system_client_id: String

  """Reference to the external system"""
  system_id: uuid!

  """Timestamp when the mapping was last updated"""
  updated_at: timestamptz
}

"""
aggregated selection of "client_external_systems"
"""
type client_external_systems_aggregate {
  aggregate: client_external_systems_aggregate_fields
  nodes: [client_external_systems!]!
}

input client_external_systems_aggregate_bool_exp {
  count: client_external_systems_aggregate_bool_exp_count
}

input client_external_systems_aggregate_bool_exp_count {
  arguments: [client_external_systems_select_column!]
  distinct: Boolean
  filter: client_external_systems_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "client_external_systems"
"""
type client_external_systems_aggregate_fields {
  count(columns: [client_external_systems_select_column!], distinct: Boolean): Int!
  max: client_external_systems_max_fields
  min: client_external_systems_min_fields
}

"""
order by aggregate values of table "client_external_systems"
"""
input client_external_systems_aggregate_order_by {
  count: order_by
  max: client_external_systems_max_order_by
  min: client_external_systems_min_order_by
}

"""
input type for inserting array relation for remote table "client_external_systems"
"""
input client_external_systems_arr_rel_insert_input {
  data: [client_external_systems_insert_input!]!

  """upsert condition"""
  on_conflict: client_external_systems_on_conflict
}

"""
Boolean expression to filter rows from the table "client_external_systems". All fields are combined with a logical 'AND'.
"""
input client_external_systems_bool_exp {
  _and: [client_external_systems_bool_exp!]
  _not: client_external_systems_bool_exp
  _or: [client_external_systems_bool_exp!]
  client: clients_bool_exp
  client_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  external_system: external_systems_bool_exp
  id: uuid_comparison_exp
  system_client_id: String_comparison_exp
  system_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "client_external_systems"
"""
enum client_external_systems_constraint {
  """
  unique or primary key constraint on columns "client_id", "system_id"
  """
  client_external_systems_client_id_system_id_key

  """
  unique or primary key constraint on columns "id"
  """
  client_external_systems_pkey
}

"""
input type for inserting data into table "client_external_systems"
"""
input client_external_systems_insert_input {
  client: clients_obj_rel_insert_input

  """Reference to the client"""
  client_id: uuid

  """Timestamp when the mapping was created"""
  created_at: timestamptz
  external_system: external_systems_obj_rel_insert_input

  """Unique identifier for the client-system mapping"""
  id: uuid

  """Client identifier in the external system"""
  system_client_id: String

  """Reference to the external system"""
  system_id: uuid

  """Timestamp when the mapping was last updated"""
  updated_at: timestamptz
}

"""aggregate max on columns"""
type client_external_systems_max_fields {
  """Reference to the client"""
  client_id: uuid

  """Timestamp when the mapping was created"""
  created_at: timestamptz

  """Unique identifier for the client-system mapping"""
  id: uuid

  """Client identifier in the external system"""
  system_client_id: String

  """Reference to the external system"""
  system_id: uuid

  """Timestamp when the mapping was last updated"""
  updated_at: timestamptz
}

"""
order by max() on columns of table "client_external_systems"
"""
input client_external_systems_max_order_by {
  """Reference to the client"""
  client_id: order_by

  """Timestamp when the mapping was created"""
  created_at: order_by

  """Unique identifier for the client-system mapping"""
  id: order_by

  """Client identifier in the external system"""
  system_client_id: order_by

  """Reference to the external system"""
  system_id: order_by

  """Timestamp when the mapping was last updated"""
  updated_at: order_by
}

"""aggregate min on columns"""
type client_external_systems_min_fields {
  """Reference to the client"""
  client_id: uuid

  """Timestamp when the mapping was created"""
  created_at: timestamptz

  """Unique identifier for the client-system mapping"""
  id: uuid

  """Client identifier in the external system"""
  system_client_id: String

  """Reference to the external system"""
  system_id: uuid

  """Timestamp when the mapping was last updated"""
  updated_at: timestamptz
}

"""
order by min() on columns of table "client_external_systems"
"""
input client_external_systems_min_order_by {
  """Reference to the client"""
  client_id: order_by

  """Timestamp when the mapping was created"""
  created_at: order_by

  """Unique identifier for the client-system mapping"""
  id: order_by

  """Client identifier in the external system"""
  system_client_id: order_by

  """Reference to the external system"""
  system_id: order_by

  """Timestamp when the mapping was last updated"""
  updated_at: order_by
}

"""
response of any mutation on the table "client_external_systems"
"""
type client_external_systems_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [client_external_systems!]!
}

"""
on_conflict condition type for table "client_external_systems"
"""
input client_external_systems_on_conflict {
  constraint: client_external_systems_constraint!
  update_columns: [client_external_systems_update_column!]! = []
  where: client_external_systems_bool_exp
}

"""Ordering options when selecting data from "client_external_systems"."""
input client_external_systems_order_by {
  client: clients_order_by
  client_id: order_by
  created_at: order_by
  external_system: external_systems_order_by
  id: order_by
  system_client_id: order_by
  system_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: client_external_systems"""
input client_external_systems_pk_columns_input {
  """Unique identifier for the client-system mapping"""
  id: uuid!
}

"""
select columns of table "client_external_systems"
"""
enum client_external_systems_select_column {
  """column name"""
  client_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  system_client_id

  """column name"""
  system_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "client_external_systems"
"""
input client_external_systems_set_input {
  """Reference to the client"""
  client_id: uuid

  """Timestamp when the mapping was created"""
  created_at: timestamptz

  """Unique identifier for the client-system mapping"""
  id: uuid

  """Client identifier in the external system"""
  system_client_id: String

  """Reference to the external system"""
  system_id: uuid

  """Timestamp when the mapping was last updated"""
  updated_at: timestamptz
}

"""
Streaming cursor of the table "client_external_systems"
"""
input client_external_systems_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: client_external_systems_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input client_external_systems_stream_cursor_value_input {
  """Reference to the client"""
  client_id: uuid

  """Timestamp when the mapping was created"""
  created_at: timestamptz

  """Unique identifier for the client-system mapping"""
  id: uuid

  """Client identifier in the external system"""
  system_client_id: String

  """Reference to the external system"""
  system_id: uuid

  """Timestamp when the mapping was last updated"""
  updated_at: timestamptz
}

"""
update columns of table "client_external_systems"
"""
enum client_external_systems_update_column {
  """column name"""
  client_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  system_client_id

  """column name"""
  system_id

  """column name"""
  updated_at
}

input client_external_systems_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: client_external_systems_set_input

  """filter the rows which have to be updated"""
  where: client_external_systems_bool_exp!
}

"""
columns and relationships of "clients"
"""
type clients {
  """Whether the client is currently active"""
  active: Boolean

  """An array relationship"""
  client_external_systems(
    """distinct select on columns"""
    distinct_on: [client_external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_external_systems_order_by!]

    """filter the rows returned"""
    where: client_external_systems_bool_exp
  ): [client_external_systems!]!

  """An aggregate relationship"""
  client_external_systems_aggregate(
    """distinct select on columns"""
    distinct_on: [client_external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_external_systems_order_by!]

    """filter the rows returned"""
    where: client_external_systems_bool_exp
  ): client_external_systems_aggregate!

  """Email address for the client contact"""
  contact_email: String

  """Primary contact person at the client"""
  contact_person: String

  """Phone number for the client contact"""
  contact_phone: String

  """Timestamp when the client was created"""
  created_at: timestamptz

  """Unique identifier for the client"""
  id: uuid!

  """Client company name"""
  name: String!

  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """An aggregate relationship"""
  payrolls_aggregate(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): payrolls_aggregate!

  """Timestamp when the client was last updated"""
  updated_at: timestamptz
}

"""
aggregated selection of "clients"
"""
type clients_aggregate {
  aggregate: clients_aggregate_fields
  nodes: [clients!]!
}

input clients_aggregate_bool_exp {
  bool_and: clients_aggregate_bool_exp_bool_and
  bool_or: clients_aggregate_bool_exp_bool_or
  count: clients_aggregate_bool_exp_count
}

input clients_aggregate_bool_exp_bool_and {
  arguments: clients_select_column_clients_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: clients_bool_exp
  predicate: Boolean_comparison_exp!
}

input clients_aggregate_bool_exp_bool_or {
  arguments: clients_select_column_clients_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: clients_bool_exp
  predicate: Boolean_comparison_exp!
}

input clients_aggregate_bool_exp_count {
  arguments: [clients_select_column!]
  distinct: Boolean
  filter: clients_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "clients"
"""
type clients_aggregate_fields {
  count(columns: [clients_select_column!], distinct: Boolean): Int!
  max: clients_max_fields
  min: clients_min_fields
}

"""
order by aggregate values of table "clients"
"""
input clients_aggregate_order_by {
  count: order_by
  max: clients_max_order_by
  min: clients_min_order_by
}

"""
input type for inserting array relation for remote table "clients"
"""
input clients_arr_rel_insert_input {
  data: [clients_insert_input!]!

  """upsert condition"""
  on_conflict: clients_on_conflict
}

"""
Boolean expression to filter rows from the table "clients". All fields are combined with a logical 'AND'.
"""
input clients_bool_exp {
  _and: [clients_bool_exp!]
  _not: clients_bool_exp
  _or: [clients_bool_exp!]
  active: Boolean_comparison_exp
  client_external_systems: client_external_systems_bool_exp
  client_external_systems_aggregate: client_external_systems_aggregate_bool_exp
  contact_email: String_comparison_exp
  contact_person: String_comparison_exp
  contact_phone: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  payrolls: payrolls_bool_exp
  payrolls_aggregate: payrolls_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "clients"
"""
enum clients_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  clients_pkey
}

"""
input type for inserting data into table "clients"
"""
input clients_insert_input {
  """Whether the client is currently active"""
  active: Boolean
  client_external_systems: client_external_systems_arr_rel_insert_input

  """Email address for the client contact"""
  contact_email: String

  """Primary contact person at the client"""
  contact_person: String

  """Phone number for the client contact"""
  contact_phone: String

  """Timestamp when the client was created"""
  created_at: timestamptz

  """Unique identifier for the client"""
  id: uuid

  """Client company name"""
  name: String
  payrolls: payrolls_arr_rel_insert_input

  """Timestamp when the client was last updated"""
  updated_at: timestamptz
}

"""aggregate max on columns"""
type clients_max_fields {
  """Email address for the client contact"""
  contact_email: String

  """Primary contact person at the client"""
  contact_person: String

  """Phone number for the client contact"""
  contact_phone: String

  """Timestamp when the client was created"""
  created_at: timestamptz

  """Unique identifier for the client"""
  id: uuid

  """Client company name"""
  name: String

  """Timestamp when the client was last updated"""
  updated_at: timestamptz
}

"""
order by max() on columns of table "clients"
"""
input clients_max_order_by {
  """Email address for the client contact"""
  contact_email: order_by

  """Primary contact person at the client"""
  contact_person: order_by

  """Phone number for the client contact"""
  contact_phone: order_by

  """Timestamp when the client was created"""
  created_at: order_by

  """Unique identifier for the client"""
  id: order_by

  """Client company name"""
  name: order_by

  """Timestamp when the client was last updated"""
  updated_at: order_by
}

"""aggregate min on columns"""
type clients_min_fields {
  """Email address for the client contact"""
  contact_email: String

  """Primary contact person at the client"""
  contact_person: String

  """Phone number for the client contact"""
  contact_phone: String

  """Timestamp when the client was created"""
  created_at: timestamptz

  """Unique identifier for the client"""
  id: uuid

  """Client company name"""
  name: String

  """Timestamp when the client was last updated"""
  updated_at: timestamptz
}

"""
order by min() on columns of table "clients"
"""
input clients_min_order_by {
  """Email address for the client contact"""
  contact_email: order_by

  """Primary contact person at the client"""
  contact_person: order_by

  """Phone number for the client contact"""
  contact_phone: order_by

  """Timestamp when the client was created"""
  created_at: order_by

  """Unique identifier for the client"""
  id: order_by

  """Client company name"""
  name: order_by

  """Timestamp when the client was last updated"""
  updated_at: order_by
}

"""
response of any mutation on the table "clients"
"""
type clients_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [clients!]!
}

"""
input type for inserting object relation for remote table "clients"
"""
input clients_obj_rel_insert_input {
  data: clients_insert_input!

  """upsert condition"""
  on_conflict: clients_on_conflict
}

"""
on_conflict condition type for table "clients"
"""
input clients_on_conflict {
  constraint: clients_constraint!
  update_columns: [clients_update_column!]! = []
  where: clients_bool_exp
}

"""Ordering options when selecting data from "clients"."""
input clients_order_by {
  active: order_by
  client_external_systems_aggregate: client_external_systems_aggregate_order_by
  contact_email: order_by
  contact_person: order_by
  contact_phone: order_by
  created_at: order_by
  id: order_by
  name: order_by
  payrolls_aggregate: payrolls_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: clients"""
input clients_pk_columns_input {
  """Unique identifier for the client"""
  id: uuid!
}

"""
select columns of table "clients"
"""
enum clients_select_column {
  """column name"""
  active

  """column name"""
  contact_email

  """column name"""
  contact_person

  """column name"""
  contact_phone

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
select "clients_aggregate_bool_exp_bool_and_arguments_columns" columns of table "clients"
"""
enum clients_select_column_clients_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  active
}

"""
select "clients_aggregate_bool_exp_bool_or_arguments_columns" columns of table "clients"
"""
enum clients_select_column_clients_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  active
}

"""
input type for updating data in table "clients"
"""
input clients_set_input {
  """Whether the client is currently active"""
  active: Boolean

  """Email address for the client contact"""
  contact_email: String

  """Primary contact person at the client"""
  contact_person: String

  """Phone number for the client contact"""
  contact_phone: String

  """Timestamp when the client was created"""
  created_at: timestamptz

  """Unique identifier for the client"""
  id: uuid

  """Client company name"""
  name: String

  """Timestamp when the client was last updated"""
  updated_at: timestamptz
}

"""
Streaming cursor of the table "clients"
"""
input clients_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: clients_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input clients_stream_cursor_value_input {
  """Whether the client is currently active"""
  active: Boolean

  """Email address for the client contact"""
  contact_email: String

  """Primary contact person at the client"""
  contact_person: String

  """Phone number for the client contact"""
  contact_phone: String

  """Timestamp when the client was created"""
  created_at: timestamptz

  """Unique identifier for the client"""
  id: uuid

  """Client company name"""
  name: String

  """Timestamp when the client was last updated"""
  updated_at: timestamptz
}

"""
update columns of table "clients"
"""
enum clients_update_column {
  """column name"""
  active

  """column name"""
  contact_email

  """column name"""
  contact_person

  """column name"""
  contact_phone

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input clients_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: clients_set_input

  """filter the rows which have to be updated"""
  where: clients_bool_exp!
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

scalar date

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""
columns and relationships of "external_systems"
"""
type external_systems {
  """An array relationship"""
  client_external_systems(
    """distinct select on columns"""
    distinct_on: [client_external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_external_systems_order_by!]

    """filter the rows returned"""
    where: client_external_systems_bool_exp
  ): [client_external_systems!]!

  """An aggregate relationship"""
  client_external_systems_aggregate(
    """distinct select on columns"""
    distinct_on: [client_external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_external_systems_order_by!]

    """filter the rows returned"""
    where: client_external_systems_bool_exp
  ): client_external_systems_aggregate!

  """Timestamp when the system was created"""
  created_at: timestamptz

  """Description of the external system and its purpose"""
  description: String

  """Path or reference to the system icon"""
  icon: String

  """Unique identifier for the external system"""
  id: uuid!

  """Name of the external system"""
  name: String!

  """Timestamp when the system was last updated"""
  updated_at: timestamptz

  """URL endpoint for the external system"""
  url: String!
}

"""
aggregated selection of "external_systems"
"""
type external_systems_aggregate {
  aggregate: external_systems_aggregate_fields
  nodes: [external_systems!]!
}

"""
aggregate fields of "external_systems"
"""
type external_systems_aggregate_fields {
  count(columns: [external_systems_select_column!], distinct: Boolean): Int!
  max: external_systems_max_fields
  min: external_systems_min_fields
}

"""
Boolean expression to filter rows from the table "external_systems". All fields are combined with a logical 'AND'.
"""
input external_systems_bool_exp {
  _and: [external_systems_bool_exp!]
  _not: external_systems_bool_exp
  _or: [external_systems_bool_exp!]
  client_external_systems: client_external_systems_bool_exp
  client_external_systems_aggregate: client_external_systems_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  icon: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  url: String_comparison_exp
}

"""
unique or primary key constraints on table "external_systems"
"""
enum external_systems_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  external_systems_pkey
}

"""
input type for inserting data into table "external_systems"
"""
input external_systems_insert_input {
  client_external_systems: client_external_systems_arr_rel_insert_input

  """Timestamp when the system was created"""
  created_at: timestamptz

  """Description of the external system and its purpose"""
  description: String

  """Path or reference to the system icon"""
  icon: String

  """Unique identifier for the external system"""
  id: uuid

  """Name of the external system"""
  name: String

  """Timestamp when the system was last updated"""
  updated_at: timestamptz

  """URL endpoint for the external system"""
  url: String
}

"""aggregate max on columns"""
type external_systems_max_fields {
  """Timestamp when the system was created"""
  created_at: timestamptz

  """Description of the external system and its purpose"""
  description: String

  """Path or reference to the system icon"""
  icon: String

  """Unique identifier for the external system"""
  id: uuid

  """Name of the external system"""
  name: String

  """Timestamp when the system was last updated"""
  updated_at: timestamptz

  """URL endpoint for the external system"""
  url: String
}

"""aggregate min on columns"""
type external_systems_min_fields {
  """Timestamp when the system was created"""
  created_at: timestamptz

  """Description of the external system and its purpose"""
  description: String

  """Path or reference to the system icon"""
  icon: String

  """Unique identifier for the external system"""
  id: uuid

  """Name of the external system"""
  name: String

  """Timestamp when the system was last updated"""
  updated_at: timestamptz

  """URL endpoint for the external system"""
  url: String
}

"""
response of any mutation on the table "external_systems"
"""
type external_systems_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [external_systems!]!
}

"""
input type for inserting object relation for remote table "external_systems"
"""
input external_systems_obj_rel_insert_input {
  data: external_systems_insert_input!

  """upsert condition"""
  on_conflict: external_systems_on_conflict
}

"""
on_conflict condition type for table "external_systems"
"""
input external_systems_on_conflict {
  constraint: external_systems_constraint!
  update_columns: [external_systems_update_column!]! = []
  where: external_systems_bool_exp
}

"""Ordering options when selecting data from "external_systems"."""
input external_systems_order_by {
  client_external_systems_aggregate: client_external_systems_aggregate_order_by
  created_at: order_by
  description: order_by
  icon: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  url: order_by
}

"""primary key columns input for table: external_systems"""
input external_systems_pk_columns_input {
  """Unique identifier for the external system"""
  id: uuid!
}

"""
select columns of table "external_systems"
"""
enum external_systems_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at

  """column name"""
  url
}

"""
input type for updating data in table "external_systems"
"""
input external_systems_set_input {
  """Timestamp when the system was created"""
  created_at: timestamptz

  """Description of the external system and its purpose"""
  description: String

  """Path or reference to the system icon"""
  icon: String

  """Unique identifier for the external system"""
  id: uuid

  """Name of the external system"""
  name: String

  """Timestamp when the system was last updated"""
  updated_at: timestamptz

  """URL endpoint for the external system"""
  url: String
}

"""
Streaming cursor of the table "external_systems"
"""
input external_systems_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: external_systems_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input external_systems_stream_cursor_value_input {
  """Timestamp when the system was created"""
  created_at: timestamptz

  """Description of the external system and its purpose"""
  description: String

  """Path or reference to the system icon"""
  icon: String

  """Unique identifier for the external system"""
  id: uuid

  """Name of the external system"""
  name: String

  """Timestamp when the system was last updated"""
  updated_at: timestamptz

  """URL endpoint for the external system"""
  url: String
}

"""
update columns of table "external_systems"
"""
enum external_systems_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at

  """column name"""
  url
}

input external_systems_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: external_systems_set_input

  """filter the rows which have to be updated"""
  where: external_systems_bool_exp!
}

"""
columns and relationships of "feature_flags"
"""
type feature_flags {
  """JSON array of roles that can access this feature"""
  allowed_roles(
    """JSON select path"""
    path: String
  ): jsonb!

  """Name of the feature controlled by this flag"""
  feature_name: String!

  """Unique identifier for the feature flag"""
  id: uuid!

  """Whether the feature is currently enabled"""
  is_enabled: Boolean

  """Timestamp when the feature flag was last updated"""
  updated_at: timestamptz
}

"""
aggregated selection of "feature_flags"
"""
type feature_flags_aggregate {
  aggregate: feature_flags_aggregate_fields
  nodes: [feature_flags!]!
}

"""
aggregate fields of "feature_flags"
"""
type feature_flags_aggregate_fields {
  count(columns: [feature_flags_select_column!], distinct: Boolean): Int!
  max: feature_flags_max_fields
  min: feature_flags_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input feature_flags_append_input {
  """JSON array of roles that can access this feature"""
  allowed_roles: jsonb
}

"""
Boolean expression to filter rows from the table "feature_flags". All fields are combined with a logical 'AND'.
"""
input feature_flags_bool_exp {
  _and: [feature_flags_bool_exp!]
  _not: feature_flags_bool_exp
  _or: [feature_flags_bool_exp!]
  allowed_roles: jsonb_comparison_exp
  feature_name: String_comparison_exp
  id: uuid_comparison_exp
  is_enabled: Boolean_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "feature_flags"
"""
enum feature_flags_constraint {
  """
  unique or primary key constraint on columns "feature_name"
  """
  feature_flags_feature_name_key

  """
  unique or primary key constraint on columns "id"
  """
  feature_flags_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input feature_flags_delete_at_path_input {
  """JSON array of roles that can access this feature"""
  allowed_roles: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input feature_flags_delete_elem_input {
  """JSON array of roles that can access this feature"""
  allowed_roles: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input feature_flags_delete_key_input {
  """JSON array of roles that can access this feature"""
  allowed_roles: String
}

"""
input type for inserting data into table "feature_flags"
"""
input feature_flags_insert_input {
  """JSON array of roles that can access this feature"""
  allowed_roles: jsonb

  """Name of the feature controlled by this flag"""
  feature_name: String

  """Unique identifier for the feature flag"""
  id: uuid

  """Whether the feature is currently enabled"""
  is_enabled: Boolean

  """Timestamp when the feature flag was last updated"""
  updated_at: timestamptz
}

"""aggregate max on columns"""
type feature_flags_max_fields {
  """Name of the feature controlled by this flag"""
  feature_name: String

  """Unique identifier for the feature flag"""
  id: uuid

  """Timestamp when the feature flag was last updated"""
  updated_at: timestamptz
}

"""aggregate min on columns"""
type feature_flags_min_fields {
  """Name of the feature controlled by this flag"""
  feature_name: String

  """Unique identifier for the feature flag"""
  id: uuid

  """Timestamp when the feature flag was last updated"""
  updated_at: timestamptz
}

"""
response of any mutation on the table "feature_flags"
"""
type feature_flags_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [feature_flags!]!
}

"""
on_conflict condition type for table "feature_flags"
"""
input feature_flags_on_conflict {
  constraint: feature_flags_constraint!
  update_columns: [feature_flags_update_column!]! = []
  where: feature_flags_bool_exp
}

"""Ordering options when selecting data from "feature_flags"."""
input feature_flags_order_by {
  allowed_roles: order_by
  feature_name: order_by
  id: order_by
  is_enabled: order_by
  updated_at: order_by
}

"""primary key columns input for table: feature_flags"""
input feature_flags_pk_columns_input {
  """Unique identifier for the feature flag"""
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input feature_flags_prepend_input {
  """JSON array of roles that can access this feature"""
  allowed_roles: jsonb
}

"""
select columns of table "feature_flags"
"""
enum feature_flags_select_column {
  """column name"""
  allowed_roles

  """column name"""
  feature_name

  """column name"""
  id

  """column name"""
  is_enabled

  """column name"""
  updated_at
}

"""
input type for updating data in table "feature_flags"
"""
input feature_flags_set_input {
  """JSON array of roles that can access this feature"""
  allowed_roles: jsonb

  """Name of the feature controlled by this flag"""
  feature_name: String

  """Unique identifier for the feature flag"""
  id: uuid

  """Whether the feature is currently enabled"""
  is_enabled: Boolean

  """Timestamp when the feature flag was last updated"""
  updated_at: timestamptz
}

"""
Streaming cursor of the table "feature_flags"
"""
input feature_flags_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: feature_flags_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input feature_flags_stream_cursor_value_input {
  """JSON array of roles that can access this feature"""
  allowed_roles: jsonb

  """Name of the feature controlled by this flag"""
  feature_name: String

  """Unique identifier for the feature flag"""
  id: uuid

  """Whether the feature is currently enabled"""
  is_enabled: Boolean

  """Timestamp when the feature flag was last updated"""
  updated_at: timestamptz
}

"""
update columns of table "feature_flags"
"""
enum feature_flags_update_column {
  """column name"""
  allowed_roles

  """column name"""
  feature_name

  """column name"""
  id

  """column name"""
  is_enabled

  """column name"""
  updated_at
}

input feature_flags_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: feature_flags_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: feature_flags_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: feature_flags_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: feature_flags_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: feature_flags_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: feature_flags_set_input

  """filter the rows which have to be updated"""
  where: feature_flags_bool_exp!
}

input generate_payroll_dates_args {
  p_end_date: date
  p_max_dates: Int
  p_payroll_id: uuid
  p_start_date: date
}

"""
columns and relationships of "holidays"
"""
type holidays {
  """ISO country code where the holiday is observed"""
  country_code: bpchar!

  """Timestamp when the holiday record was created"""
  created_at: timestamptz

  """Date of the holiday"""
  date: date!

  """Unique identifier for the holiday"""
  id: uuid!

  """Whether the holiday occurs on the same date each year"""
  is_fixed: Boolean

  """Whether the holiday is observed globally"""
  is_global: Boolean

  """First year when the holiday was observed"""
  launch_year: Int

  """Name of the holiday in local language"""
  local_name: String!

  """Name of the holiday in English"""
  name: String!

  """Array of regions within the country where the holiday applies"""
  region: [String!]

  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]!

  """Timestamp when the holiday record was last updated"""
  updated_at: timestamptz
}

"""
aggregated selection of "holidays"
"""
type holidays_aggregate {
  aggregate: holidays_aggregate_fields
  nodes: [holidays!]!
}

"""
aggregate fields of "holidays"
"""
type holidays_aggregate_fields {
  avg: holidays_avg_fields
  count(columns: [holidays_select_column!], distinct: Boolean): Int!
  max: holidays_max_fields
  min: holidays_min_fields
  stddev: holidays_stddev_fields
  stddev_pop: holidays_stddev_pop_fields
  stddev_samp: holidays_stddev_samp_fields
  sum: holidays_sum_fields
  var_pop: holidays_var_pop_fields
  var_samp: holidays_var_samp_fields
  variance: holidays_variance_fields
}

"""aggregate avg on columns"""
type holidays_avg_fields {
  """First year when the holiday was observed"""
  launch_year: Float
}

"""
Boolean expression to filter rows from the table "holidays". All fields are combined with a logical 'AND'.
"""
input holidays_bool_exp {
  _and: [holidays_bool_exp!]
  _not: holidays_bool_exp
  _or: [holidays_bool_exp!]
  country_code: bpchar_comparison_exp
  created_at: timestamptz_comparison_exp
  date: date_comparison_exp
  id: uuid_comparison_exp
  is_fixed: Boolean_comparison_exp
  is_global: Boolean_comparison_exp
  launch_year: Int_comparison_exp
  local_name: String_comparison_exp
  name: String_comparison_exp
  region: String_array_comparison_exp
  types: String_array_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "holidays"
"""
enum holidays_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  holidays_pkey
}

"""
input type for incrementing numeric columns in table "holidays"
"""
input holidays_inc_input {
  """First year when the holiday was observed"""
  launch_year: Int
}

"""
input type for inserting data into table "holidays"
"""
input holidays_insert_input {
  """ISO country code where the holiday is observed"""
  country_code: bpchar

  """Timestamp when the holiday record was created"""
  created_at: timestamptz

  """Date of the holiday"""
  date: date

  """Unique identifier for the holiday"""
  id: uuid

  """Whether the holiday occurs on the same date each year"""
  is_fixed: Boolean

  """Whether the holiday is observed globally"""
  is_global: Boolean

  """First year when the holiday was observed"""
  launch_year: Int

  """Name of the holiday in local language"""
  local_name: String

  """Name of the holiday in English"""
  name: String

  """Array of regions within the country where the holiday applies"""
  region: [String!]

  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]

  """Timestamp when the holiday record was last updated"""
  updated_at: timestamptz
}

"""aggregate max on columns"""
type holidays_max_fields {
  """ISO country code where the holiday is observed"""
  country_code: bpchar

  """Timestamp when the holiday record was created"""
  created_at: timestamptz

  """Date of the holiday"""
  date: date

  """Unique identifier for the holiday"""
  id: uuid

  """First year when the holiday was observed"""
  launch_year: Int

  """Name of the holiday in local language"""
  local_name: String

  """Name of the holiday in English"""
  name: String

  """Array of regions within the country where the holiday applies"""
  region: [String!]

  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]

  """Timestamp when the holiday record was last updated"""
  updated_at: timestamptz
}

"""aggregate min on columns"""
type holidays_min_fields {
  """ISO country code where the holiday is observed"""
  country_code: bpchar

  """Timestamp when the holiday record was created"""
  created_at: timestamptz

  """Date of the holiday"""
  date: date

  """Unique identifier for the holiday"""
  id: uuid

  """First year when the holiday was observed"""
  launch_year: Int

  """Name of the holiday in local language"""
  local_name: String

  """Name of the holiday in English"""
  name: String

  """Array of regions within the country where the holiday applies"""
  region: [String!]

  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]

  """Timestamp when the holiday record was last updated"""
  updated_at: timestamptz
}

"""
response of any mutation on the table "holidays"
"""
type holidays_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [holidays!]!
}

"""
on_conflict condition type for table "holidays"
"""
input holidays_on_conflict {
  constraint: holidays_constraint!
  update_columns: [holidays_update_column!]! = []
  where: holidays_bool_exp
}

"""Ordering options when selecting data from "holidays"."""
input holidays_order_by {
  country_code: order_by
  created_at: order_by
  date: order_by
  id: order_by
  is_fixed: order_by
  is_global: order_by
  launch_year: order_by
  local_name: order_by
  name: order_by
  region: order_by
  types: order_by
  updated_at: order_by
}

"""primary key columns input for table: holidays"""
input holidays_pk_columns_input {
  """Unique identifier for the holiday"""
  id: uuid!
}

"""
select columns of table "holidays"
"""
enum holidays_select_column {
  """column name"""
  country_code

  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  id

  """column name"""
  is_fixed

  """column name"""
  is_global

  """column name"""
  launch_year

  """column name"""
  local_name

  """column name"""
  name

  """column name"""
  region

  """column name"""
  types

  """column name"""
  updated_at
}

"""
input type for updating data in table "holidays"
"""
input holidays_set_input {
  """ISO country code where the holiday is observed"""
  country_code: bpchar

  """Timestamp when the holiday record was created"""
  created_at: timestamptz

  """Date of the holiday"""
  date: date

  """Unique identifier for the holiday"""
  id: uuid

  """Whether the holiday occurs on the same date each year"""
  is_fixed: Boolean

  """Whether the holiday is observed globally"""
  is_global: Boolean

  """First year when the holiday was observed"""
  launch_year: Int

  """Name of the holiday in local language"""
  local_name: String

  """Name of the holiday in English"""
  name: String

  """Array of regions within the country where the holiday applies"""
  region: [String!]

  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]

  """Timestamp when the holiday record was last updated"""
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type holidays_stddev_fields {
  """First year when the holiday was observed"""
  launch_year: Float
}

"""aggregate stddev_pop on columns"""
type holidays_stddev_pop_fields {
  """First year when the holiday was observed"""
  launch_year: Float
}

"""aggregate stddev_samp on columns"""
type holidays_stddev_samp_fields {
  """First year when the holiday was observed"""
  launch_year: Float
}

"""
Streaming cursor of the table "holidays"
"""
input holidays_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: holidays_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input holidays_stream_cursor_value_input {
  """ISO country code where the holiday is observed"""
  country_code: bpchar

  """Timestamp when the holiday record was created"""
  created_at: timestamptz

  """Date of the holiday"""
  date: date

  """Unique identifier for the holiday"""
  id: uuid

  """Whether the holiday occurs on the same date each year"""
  is_fixed: Boolean

  """Whether the holiday is observed globally"""
  is_global: Boolean

  """First year when the holiday was observed"""
  launch_year: Int

  """Name of the holiday in local language"""
  local_name: String

  """Name of the holiday in English"""
  name: String

  """Array of regions within the country where the holiday applies"""
  region: [String!]

  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]

  """Timestamp when the holiday record was last updated"""
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type holidays_sum_fields {
  """First year when the holiday was observed"""
  launch_year: Int
}

"""
update columns of table "holidays"
"""
enum holidays_update_column {
  """column name"""
  country_code

  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  id

  """column name"""
  is_fixed

  """column name"""
  is_global

  """column name"""
  launch_year

  """column name"""
  local_name

  """column name"""
  name

  """column name"""
  region

  """column name"""
  types

  """column name"""
  updated_at
}

input holidays_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: holidays_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: holidays_set_input

  """filter the rows which have to be updated"""
  where: holidays_bool_exp!
}

"""aggregate var_pop on columns"""
type holidays_var_pop_fields {
  """First year when the holiday was observed"""
  launch_year: Float
}

"""aggregate var_samp on columns"""
type holidays_var_samp_fields {
  """First year when the holiday was observed"""
  launch_year: Float
}

"""aggregate variance on columns"""
type holidays_variance_fields {
  """First year when the holiday was observed"""
  launch_year: Float
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "leave"
"""
type leave {
  """Last day of the leave period"""
  end_date: date!

  """Unique identifier for the leave record"""
  id: uuid!

  """Type of leave (vacation, sick, personal, etc.)"""
  leave_type: String!

  """An object relationship"""
  leave_user: users!

  """Reason provided for the leave request"""
  reason: String

  """First day of the leave period"""
  start_date: date!

  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum

  """An object relationship"""
  user: users!

  """Reference to the user taking leave"""
  user_id: uuid!
}

"""
aggregated selection of "leave"
"""
type leave_aggregate {
  aggregate: leave_aggregate_fields
  nodes: [leave!]!
}

input leave_aggregate_bool_exp {
  count: leave_aggregate_bool_exp_count
}

input leave_aggregate_bool_exp_count {
  arguments: [leave_select_column!]
  distinct: Boolean
  filter: leave_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "leave"
"""
type leave_aggregate_fields {
  count(columns: [leave_select_column!], distinct: Boolean): Int!
  max: leave_max_fields
  min: leave_min_fields
}

"""
order by aggregate values of table "leave"
"""
input leave_aggregate_order_by {
  count: order_by
  max: leave_max_order_by
  min: leave_min_order_by
}

"""
input type for inserting array relation for remote table "leave"
"""
input leave_arr_rel_insert_input {
  data: [leave_insert_input!]!

  """upsert condition"""
  on_conflict: leave_on_conflict
}

"""
Boolean expression to filter rows from the table "leave". All fields are combined with a logical 'AND'.
"""
input leave_bool_exp {
  _and: [leave_bool_exp!]
  _not: leave_bool_exp
  _or: [leave_bool_exp!]
  end_date: date_comparison_exp
  id: uuid_comparison_exp
  leave_type: String_comparison_exp
  leave_user: users_bool_exp
  reason: String_comparison_exp
  start_date: date_comparison_exp
  status: leave_status_enum_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "leave"
"""
enum leave_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  leave_pkey
}

"""
input type for inserting data into table "leave"
"""
input leave_insert_input {
  """Last day of the leave period"""
  end_date: date

  """Unique identifier for the leave record"""
  id: uuid

  """Type of leave (vacation, sick, personal, etc.)"""
  leave_type: String
  leave_user: users_obj_rel_insert_input

  """Reason provided for the leave request"""
  reason: String

  """First day of the leave period"""
  start_date: date

  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum
  user: users_obj_rel_insert_input

  """Reference to the user taking leave"""
  user_id: uuid
}

"""aggregate max on columns"""
type leave_max_fields {
  """Last day of the leave period"""
  end_date: date

  """Unique identifier for the leave record"""
  id: uuid

  """Type of leave (vacation, sick, personal, etc.)"""
  leave_type: String

  """Reason provided for the leave request"""
  reason: String

  """First day of the leave period"""
  start_date: date

  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum

  """Reference to the user taking leave"""
  user_id: uuid
}

"""
order by max() on columns of table "leave"
"""
input leave_max_order_by {
  """Last day of the leave period"""
  end_date: order_by

  """Unique identifier for the leave record"""
  id: order_by

  """Type of leave (vacation, sick, personal, etc.)"""
  leave_type: order_by

  """Reason provided for the leave request"""
  reason: order_by

  """First day of the leave period"""
  start_date: order_by

  """Current status of the leave request (Pending, Approved, Denied)"""
  status: order_by

  """Reference to the user taking leave"""
  user_id: order_by
}

"""aggregate min on columns"""
type leave_min_fields {
  """Last day of the leave period"""
  end_date: date

  """Unique identifier for the leave record"""
  id: uuid

  """Type of leave (vacation, sick, personal, etc.)"""
  leave_type: String

  """Reason provided for the leave request"""
  reason: String

  """First day of the leave period"""
  start_date: date

  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum

  """Reference to the user taking leave"""
  user_id: uuid
}

"""
order by min() on columns of table "leave"
"""
input leave_min_order_by {
  """Last day of the leave period"""
  end_date: order_by

  """Unique identifier for the leave record"""
  id: order_by

  """Type of leave (vacation, sick, personal, etc.)"""
  leave_type: order_by

  """Reason provided for the leave request"""
  reason: order_by

  """First day of the leave period"""
  start_date: order_by

  """Current status of the leave request (Pending, Approved, Denied)"""
  status: order_by

  """Reference to the user taking leave"""
  user_id: order_by
}

"""
response of any mutation on the table "leave"
"""
type leave_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [leave!]!
}

"""
on_conflict condition type for table "leave"
"""
input leave_on_conflict {
  constraint: leave_constraint!
  update_columns: [leave_update_column!]! = []
  where: leave_bool_exp
}

"""Ordering options when selecting data from "leave"."""
input leave_order_by {
  end_date: order_by
  id: order_by
  leave_type: order_by
  leave_user: users_order_by
  reason: order_by
  start_date: order_by
  status: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: leave"""
input leave_pk_columns_input {
  """Unique identifier for the leave record"""
  id: uuid!
}

"""
select columns of table "leave"
"""
enum leave_select_column {
  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  leave_type

  """column name"""
  reason

  """column name"""
  start_date

  """column name"""
  status

  """column name"""
  user_id
}

"""
input type for updating data in table "leave"
"""
input leave_set_input {
  """Last day of the leave period"""
  end_date: date

  """Unique identifier for the leave record"""
  id: uuid

  """Type of leave (vacation, sick, personal, etc.)"""
  leave_type: String

  """Reason provided for the leave request"""
  reason: String

  """First day of the leave period"""
  start_date: date

  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum

  """Reference to the user taking leave"""
  user_id: uuid
}

scalar leave_status_enum

"""
Boolean expression to compare columns of type "leave_status_enum". All fields are combined with logical 'AND'.
"""
input leave_status_enum_comparison_exp {
  _eq: leave_status_enum
  _gt: leave_status_enum
  _gte: leave_status_enum
  _in: [leave_status_enum!]
  _is_null: Boolean
  _lt: leave_status_enum
  _lte: leave_status_enum
  _neq: leave_status_enum
  _nin: [leave_status_enum!]
}

"""
Streaming cursor of the table "leave"
"""
input leave_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: leave_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input leave_stream_cursor_value_input {
  """Last day of the leave period"""
  end_date: date

  """Unique identifier for the leave record"""
  id: uuid

  """Type of leave (vacation, sick, personal, etc.)"""
  leave_type: String

  """Reason provided for the leave request"""
  reason: String

  """First day of the leave period"""
  start_date: date

  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum

  """Reference to the user taking leave"""
  user_id: uuid
}

"""
update columns of table "leave"
"""
enum leave_update_column {
  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  leave_type

  """column name"""
  reason

  """column name"""
  start_date

  """column name"""
  status

  """column name"""
  user_id
}

input leave_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: leave_set_input

  """filter the rows which have to be updated"""
  where: leave_bool_exp!
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "adjustment_rules"
  """
  delete_adjustment_rules(
    """filter the rows which have to be deleted"""
    where: adjustment_rules_bool_exp!
  ): adjustment_rules_mutation_response

  """
  delete single row from the table: "adjustment_rules"
  """
  delete_adjustment_rules_by_pk(
    """Unique identifier for the adjustment rule"""
    id: uuid!
  ): adjustment_rules

  """
  delete data from the table: "app_settings"
  """
  delete_app_settings(
    """filter the rows which have to be deleted"""
    where: app_settings_bool_exp!
  ): app_settings_mutation_response

  """
  delete single row from the table: "app_settings"
  """
  delete_app_settings_by_pk(
    """Unique identifier for application setting"""
    id: String!
  ): app_settings

  """
  delete data from the table: "client_external_systems"
  """
  delete_client_external_systems(
    """filter the rows which have to be deleted"""
    where: client_external_systems_bool_exp!
  ): client_external_systems_mutation_response

  """
  delete single row from the table: "client_external_systems"
  """
  delete_client_external_systems_by_pk(
    """Unique identifier for the client-system mapping"""
    id: uuid!
  ): client_external_systems

  """
  delete data from the table: "clients"
  """
  delete_clients(
    """filter the rows which have to be deleted"""
    where: clients_bool_exp!
  ): clients_mutation_response

  """
  delete single row from the table: "clients"
  """
  delete_clients_by_pk(
    """Unique identifier for the client"""
    id: uuid!
  ): clients

  """
  delete data from the table: "external_systems"
  """
  delete_external_systems(
    """filter the rows which have to be deleted"""
    where: external_systems_bool_exp!
  ): external_systems_mutation_response

  """
  delete single row from the table: "external_systems"
  """
  delete_external_systems_by_pk(
    """Unique identifier for the external system"""
    id: uuid!
  ): external_systems

  """
  delete data from the table: "feature_flags"
  """
  delete_feature_flags(
    """filter the rows which have to be deleted"""
    where: feature_flags_bool_exp!
  ): feature_flags_mutation_response

  """
  delete single row from the table: "feature_flags"
  """
  delete_feature_flags_by_pk(
    """Unique identifier for the feature flag"""
    id: uuid!
  ): feature_flags

  """
  delete data from the table: "holidays"
  """
  delete_holidays(
    """filter the rows which have to be deleted"""
    where: holidays_bool_exp!
  ): holidays_mutation_response

  """
  delete single row from the table: "holidays"
  """
  delete_holidays_by_pk(
    """Unique identifier for the holiday"""
    id: uuid!
  ): holidays

  """
  delete data from the table: "leave"
  """
  delete_leave(
    """filter the rows which have to be deleted"""
    where: leave_bool_exp!
  ): leave_mutation_response

  """
  delete single row from the table: "leave"
  """
  delete_leave_by_pk(
    """Unique identifier for the leave record"""
    id: uuid!
  ): leave

  """
  delete data from the table: "neon_auth.users_sync"
  """
  delete_neon_auth_users_sync(
    """filter the rows which have to be deleted"""
    where: neon_auth_users_sync_bool_exp!
  ): neon_auth_users_sync_mutation_response

  """
  delete single row from the table: "neon_auth.users_sync"
  """
  delete_neon_auth_users_sync_by_pk(
    """Unique identifier from the authentication provider"""
    id: String!
  ): neon_auth_users_sync

  """
  delete data from the table: "notes"
  """
  delete_notes(
    """filter the rows which have to be deleted"""
    where: notes_bool_exp!
  ): notes_mutation_response

  """
  delete single row from the table: "notes"
  """
  delete_notes_by_pk(
    """Unique identifier for the note"""
    id: uuid!
  ): notes

  """
  delete data from the table: "payroll_cycles"
  """
  delete_payroll_cycles(
    """filter the rows which have to be deleted"""
    where: payroll_cycles_bool_exp!
  ): payroll_cycles_mutation_response

  """
  delete single row from the table: "payroll_cycles"
  """
  delete_payroll_cycles_by_pk(
    """Unique identifier for the payroll cycle"""
    id: uuid!
  ): payroll_cycles

  """
  delete data from the table: "payroll_date_types"
  """
  delete_payroll_date_types(
    """filter the rows which have to be deleted"""
    where: payroll_date_types_bool_exp!
  ): payroll_date_types_mutation_response

  """
  delete single row from the table: "payroll_date_types"
  """
  delete_payroll_date_types_by_pk(
    """Unique identifier for the payroll date type"""
    id: uuid!
  ): payroll_date_types

  """
  delete data from the table: "payroll_dates"
  """
  delete_payroll_dates(
    """filter the rows which have to be deleted"""
    where: payroll_dates_bool_exp!
  ): payroll_dates_mutation_response

  """
  delete single row from the table: "payroll_dates"
  """
  delete_payroll_dates_by_pk(
    """Unique identifier for the payroll date"""
    id: uuid!
  ): payroll_dates

  """
  delete data from the table: "payrolls"
  """
  delete_payrolls(
    """filter the rows which have to be deleted"""
    where: payrolls_bool_exp!
  ): payrolls_mutation_response

  """
  delete single row from the table: "payrolls"
  """
  delete_payrolls_by_pk(
    """Unique identifier for the payroll"""
    id: uuid!
  ): payrolls

  """
  delete data from the table: "permission_audit_log"
  """
  delete_permission_audit_log(
    """filter the rows which have to be deleted"""
    where: permission_audit_log_bool_exp!
  ): permission_audit_log_mutation_response

  """
  delete single row from the table: "permission_audit_log"
  """
  delete_permission_audit_log_by_pk(
    """Unique identifier for the audit log entry"""
    id: uuid!
  ): permission_audit_log

  """
  delete data from the table: "permission_overrides"
  """
  delete_permission_overrides(
    """filter the rows which have to be deleted"""
    where: permission_overrides_bool_exp!
  ): permission_overrides_mutation_response

  """
  delete single row from the table: "permission_overrides"
  """
  delete_permission_overrides_by_pk(
    """Unique identifier for the permission override"""
    id: uuid!
  ): permission_overrides

  """
  delete data from the table: "users"
  """
  delete_users(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(
    """Unique identifier for the user"""
    id: uuid!
  ): users

  """
  delete data from the table: "work_schedule"
  """
  delete_work_schedule(
    """filter the rows which have to be deleted"""
    where: work_schedule_bool_exp!
  ): work_schedule_mutation_response

  """
  delete single row from the table: "work_schedule"
  """
  delete_work_schedule_by_pk(
    """Unique identifier for the work schedule entry"""
    id: uuid!
  ): work_schedule

  """
  insert data into the table: "adjustment_rules"
  """
  insert_adjustment_rules(
    """the rows to be inserted"""
    objects: [adjustment_rules_insert_input!]!

    """upsert condition"""
    on_conflict: adjustment_rules_on_conflict
  ): adjustment_rules_mutation_response

  """
  insert a single row into the table: "adjustment_rules"
  """
  insert_adjustment_rules_one(
    """the row to be inserted"""
    object: adjustment_rules_insert_input!

    """upsert condition"""
    on_conflict: adjustment_rules_on_conflict
  ): adjustment_rules

  """
  insert data into the table: "app_settings"
  """
  insert_app_settings(
    """the rows to be inserted"""
    objects: [app_settings_insert_input!]!

    """upsert condition"""
    on_conflict: app_settings_on_conflict
  ): app_settings_mutation_response

  """
  insert a single row into the table: "app_settings"
  """
  insert_app_settings_one(
    """the row to be inserted"""
    object: app_settings_insert_input!

    """upsert condition"""
    on_conflict: app_settings_on_conflict
  ): app_settings

  """
  insert data into the table: "client_external_systems"
  """
  insert_client_external_systems(
    """the rows to be inserted"""
    objects: [client_external_systems_insert_input!]!

    """upsert condition"""
    on_conflict: client_external_systems_on_conflict
  ): client_external_systems_mutation_response

  """
  insert a single row into the table: "client_external_systems"
  """
  insert_client_external_systems_one(
    """the row to be inserted"""
    object: client_external_systems_insert_input!

    """upsert condition"""
    on_conflict: client_external_systems_on_conflict
  ): client_external_systems

  """
  insert data into the table: "clients"
  """
  insert_clients(
    """the rows to be inserted"""
    objects: [clients_insert_input!]!

    """upsert condition"""
    on_conflict: clients_on_conflict
  ): clients_mutation_response

  """
  insert a single row into the table: "clients"
  """
  insert_clients_one(
    """the row to be inserted"""
    object: clients_insert_input!

    """upsert condition"""
    on_conflict: clients_on_conflict
  ): clients

  """
  insert data into the table: "external_systems"
  """
  insert_external_systems(
    """the rows to be inserted"""
    objects: [external_systems_insert_input!]!

    """upsert condition"""
    on_conflict: external_systems_on_conflict
  ): external_systems_mutation_response

  """
  insert a single row into the table: "external_systems"
  """
  insert_external_systems_one(
    """the row to be inserted"""
    object: external_systems_insert_input!

    """upsert condition"""
    on_conflict: external_systems_on_conflict
  ): external_systems

  """
  insert data into the table: "feature_flags"
  """
  insert_feature_flags(
    """the rows to be inserted"""
    objects: [feature_flags_insert_input!]!

    """upsert condition"""
    on_conflict: feature_flags_on_conflict
  ): feature_flags_mutation_response

  """
  insert a single row into the table: "feature_flags"
  """
  insert_feature_flags_one(
    """the row to be inserted"""
    object: feature_flags_insert_input!

    """upsert condition"""
    on_conflict: feature_flags_on_conflict
  ): feature_flags

  """
  insert data into the table: "holidays"
  """
  insert_holidays(
    """the rows to be inserted"""
    objects: [holidays_insert_input!]!

    """upsert condition"""
    on_conflict: holidays_on_conflict
  ): holidays_mutation_response

  """
  insert a single row into the table: "holidays"
  """
  insert_holidays_one(
    """the row to be inserted"""
    object: holidays_insert_input!

    """upsert condition"""
    on_conflict: holidays_on_conflict
  ): holidays

  """
  insert data into the table: "leave"
  """
  insert_leave(
    """the rows to be inserted"""
    objects: [leave_insert_input!]!

    """upsert condition"""
    on_conflict: leave_on_conflict
  ): leave_mutation_response

  """
  insert a single row into the table: "leave"
  """
  insert_leave_one(
    """the row to be inserted"""
    object: leave_insert_input!

    """upsert condition"""
    on_conflict: leave_on_conflict
  ): leave

  """
  insert data into the table: "neon_auth.users_sync"
  """
  insert_neon_auth_users_sync(
    """the rows to be inserted"""
    objects: [neon_auth_users_sync_insert_input!]!

    """upsert condition"""
    on_conflict: neon_auth_users_sync_on_conflict
  ): neon_auth_users_sync_mutation_response

  """
  insert a single row into the table: "neon_auth.users_sync"
  """
  insert_neon_auth_users_sync_one(
    """the row to be inserted"""
    object: neon_auth_users_sync_insert_input!

    """upsert condition"""
    on_conflict: neon_auth_users_sync_on_conflict
  ): neon_auth_users_sync

  """
  insert data into the table: "notes"
  """
  insert_notes(
    """the rows to be inserted"""
    objects: [notes_insert_input!]!

    """upsert condition"""
    on_conflict: notes_on_conflict
  ): notes_mutation_response

  """
  insert a single row into the table: "notes"
  """
  insert_notes_one(
    """the row to be inserted"""
    object: notes_insert_input!

    """upsert condition"""
    on_conflict: notes_on_conflict
  ): notes

  """
  insert data into the table: "payroll_cycles"
  """
  insert_payroll_cycles(
    """the rows to be inserted"""
    objects: [payroll_cycles_insert_input!]!

    """upsert condition"""
    on_conflict: payroll_cycles_on_conflict
  ): payroll_cycles_mutation_response

  """
  insert a single row into the table: "payroll_cycles"
  """
  insert_payroll_cycles_one(
    """the row to be inserted"""
    object: payroll_cycles_insert_input!

    """upsert condition"""
    on_conflict: payroll_cycles_on_conflict
  ): payroll_cycles

  """
  insert data into the table: "payroll_date_types"
  """
  insert_payroll_date_types(
    """the rows to be inserted"""
    objects: [payroll_date_types_insert_input!]!

    """upsert condition"""
    on_conflict: payroll_date_types_on_conflict
  ): payroll_date_types_mutation_response

  """
  insert a single row into the table: "payroll_date_types"
  """
  insert_payroll_date_types_one(
    """the row to be inserted"""
    object: payroll_date_types_insert_input!

    """upsert condition"""
    on_conflict: payroll_date_types_on_conflict
  ): payroll_date_types

  """
  insert data into the table: "payroll_dates"
  """
  insert_payroll_dates(
    """the rows to be inserted"""
    objects: [payroll_dates_insert_input!]!

    """upsert condition"""
    on_conflict: payroll_dates_on_conflict
  ): payroll_dates_mutation_response

  """
  insert a single row into the table: "payroll_dates"
  """
  insert_payroll_dates_one(
    """the row to be inserted"""
    object: payroll_dates_insert_input!

    """upsert condition"""
    on_conflict: payroll_dates_on_conflict
  ): payroll_dates

  """
  insert data into the table: "payrolls"
  """
  insert_payrolls(
    """the rows to be inserted"""
    objects: [payrolls_insert_input!]!

    """upsert condition"""
    on_conflict: payrolls_on_conflict
  ): payrolls_mutation_response

  """
  insert a single row into the table: "payrolls"
  """
  insert_payrolls_one(
    """the row to be inserted"""
    object: payrolls_insert_input!

    """upsert condition"""
    on_conflict: payrolls_on_conflict
  ): payrolls

  """
  insert data into the table: "permission_audit_log"
  """
  insert_permission_audit_log(
    """the rows to be inserted"""
    objects: [permission_audit_log_insert_input!]!

    """upsert condition"""
    on_conflict: permission_audit_log_on_conflict
  ): permission_audit_log_mutation_response

  """
  insert a single row into the table: "permission_audit_log"
  """
  insert_permission_audit_log_one(
    """the row to be inserted"""
    object: permission_audit_log_insert_input!

    """upsert condition"""
    on_conflict: permission_audit_log_on_conflict
  ): permission_audit_log

  """
  insert data into the table: "permission_overrides"
  """
  insert_permission_overrides(
    """the rows to be inserted"""
    objects: [permission_overrides_insert_input!]!

    """upsert condition"""
    on_conflict: permission_overrides_on_conflict
  ): permission_overrides_mutation_response

  """
  insert a single row into the table: "permission_overrides"
  """
  insert_permission_overrides_one(
    """the row to be inserted"""
    object: permission_overrides_insert_input!

    """upsert condition"""
    on_conflict: permission_overrides_on_conflict
  ): permission_overrides

  """
  insert data into the table: "users"
  """
  insert_users(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "users"
  """
  insert_users_one(
    """the row to be inserted"""
    object: users_insert_input!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users

  """
  insert data into the table: "work_schedule"
  """
  insert_work_schedule(
    """the rows to be inserted"""
    objects: [work_schedule_insert_input!]!

    """upsert condition"""
    on_conflict: work_schedule_on_conflict
  ): work_schedule_mutation_response

  """
  insert a single row into the table: "work_schedule"
  """
  insert_work_schedule_one(
    """the row to be inserted"""
    object: work_schedule_insert_input!

    """upsert condition"""
    on_conflict: work_schedule_on_conflict
  ): work_schedule

  """
  update data of the table: "adjustment_rules"
  """
  update_adjustment_rules(
    """sets the columns of the filtered rows to the given values"""
    _set: adjustment_rules_set_input

    """filter the rows which have to be updated"""
    where: adjustment_rules_bool_exp!
  ): adjustment_rules_mutation_response

  """
  update single row of the table: "adjustment_rules"
  """
  update_adjustment_rules_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: adjustment_rules_set_input
    pk_columns: adjustment_rules_pk_columns_input!
  ): adjustment_rules

  """
  update multiples rows of table: "adjustment_rules"
  """
  update_adjustment_rules_many(
    """updates to execute, in order"""
    updates: [adjustment_rules_updates!]!
  ): [adjustment_rules_mutation_response]

  """
  update data of the table: "app_settings"
  """
  update_app_settings(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: app_settings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: app_settings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: app_settings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: app_settings_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: app_settings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: app_settings_set_input

    """filter the rows which have to be updated"""
    where: app_settings_bool_exp!
  ): app_settings_mutation_response

  """
  update single row of the table: "app_settings"
  """
  update_app_settings_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: app_settings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: app_settings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: app_settings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: app_settings_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: app_settings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: app_settings_set_input
    pk_columns: app_settings_pk_columns_input!
  ): app_settings

  """
  update multiples rows of table: "app_settings"
  """
  update_app_settings_many(
    """updates to execute, in order"""
    updates: [app_settings_updates!]!
  ): [app_settings_mutation_response]

  """
  update data of the table: "client_external_systems"
  """
  update_client_external_systems(
    """sets the columns of the filtered rows to the given values"""
    _set: client_external_systems_set_input

    """filter the rows which have to be updated"""
    where: client_external_systems_bool_exp!
  ): client_external_systems_mutation_response

  """
  update single row of the table: "client_external_systems"
  """
  update_client_external_systems_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: client_external_systems_set_input
    pk_columns: client_external_systems_pk_columns_input!
  ): client_external_systems

  """
  update multiples rows of table: "client_external_systems"
  """
  update_client_external_systems_many(
    """updates to execute, in order"""
    updates: [client_external_systems_updates!]!
  ): [client_external_systems_mutation_response]

  """
  update data of the table: "clients"
  """
  update_clients(
    """sets the columns of the filtered rows to the given values"""
    _set: clients_set_input

    """filter the rows which have to be updated"""
    where: clients_bool_exp!
  ): clients_mutation_response

  """
  update single row of the table: "clients"
  """
  update_clients_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: clients_set_input
    pk_columns: clients_pk_columns_input!
  ): clients

  """
  update multiples rows of table: "clients"
  """
  update_clients_many(
    """updates to execute, in order"""
    updates: [clients_updates!]!
  ): [clients_mutation_response]

  """
  update data of the table: "external_systems"
  """
  update_external_systems(
    """sets the columns of the filtered rows to the given values"""
    _set: external_systems_set_input

    """filter the rows which have to be updated"""
    where: external_systems_bool_exp!
  ): external_systems_mutation_response

  """
  update single row of the table: "external_systems"
  """
  update_external_systems_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: external_systems_set_input
    pk_columns: external_systems_pk_columns_input!
  ): external_systems

  """
  update multiples rows of table: "external_systems"
  """
  update_external_systems_many(
    """updates to execute, in order"""
    updates: [external_systems_updates!]!
  ): [external_systems_mutation_response]

  """
  update data of the table: "feature_flags"
  """
  update_feature_flags(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: feature_flags_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: feature_flags_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: feature_flags_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: feature_flags_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: feature_flags_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: feature_flags_set_input

    """filter the rows which have to be updated"""
    where: feature_flags_bool_exp!
  ): feature_flags_mutation_response

  """
  update single row of the table: "feature_flags"
  """
  update_feature_flags_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: feature_flags_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: feature_flags_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: feature_flags_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: feature_flags_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: feature_flags_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: feature_flags_set_input
    pk_columns: feature_flags_pk_columns_input!
  ): feature_flags

  """
  update multiples rows of table: "feature_flags"
  """
  update_feature_flags_many(
    """updates to execute, in order"""
    updates: [feature_flags_updates!]!
  ): [feature_flags_mutation_response]

  """
  update data of the table: "holidays"
  """
  update_holidays(
    """increments the numeric columns with given value of the filtered values"""
    _inc: holidays_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: holidays_set_input

    """filter the rows which have to be updated"""
    where: holidays_bool_exp!
  ): holidays_mutation_response

  """
  update single row of the table: "holidays"
  """
  update_holidays_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: holidays_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: holidays_set_input
    pk_columns: holidays_pk_columns_input!
  ): holidays

  """
  update multiples rows of table: "holidays"
  """
  update_holidays_many(
    """updates to execute, in order"""
    updates: [holidays_updates!]!
  ): [holidays_mutation_response]

  """
  update data of the table: "leave"
  """
  update_leave(
    """sets the columns of the filtered rows to the given values"""
    _set: leave_set_input

    """filter the rows which have to be updated"""
    where: leave_bool_exp!
  ): leave_mutation_response

  """
  update single row of the table: "leave"
  """
  update_leave_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: leave_set_input
    pk_columns: leave_pk_columns_input!
  ): leave

  """
  update multiples rows of table: "leave"
  """
  update_leave_many(
    """updates to execute, in order"""
    updates: [leave_updates!]!
  ): [leave_mutation_response]

  """
  update data of the table: "neon_auth.users_sync"
  """
  update_neon_auth_users_sync(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: neon_auth_users_sync_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: neon_auth_users_sync_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: neon_auth_users_sync_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: neon_auth_users_sync_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: neon_auth_users_sync_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: neon_auth_users_sync_set_input

    """filter the rows which have to be updated"""
    where: neon_auth_users_sync_bool_exp!
  ): neon_auth_users_sync_mutation_response

  """
  update single row of the table: "neon_auth.users_sync"
  """
  update_neon_auth_users_sync_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: neon_auth_users_sync_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: neon_auth_users_sync_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: neon_auth_users_sync_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: neon_auth_users_sync_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: neon_auth_users_sync_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: neon_auth_users_sync_set_input
    pk_columns: neon_auth_users_sync_pk_columns_input!
  ): neon_auth_users_sync

  """
  update multiples rows of table: "neon_auth.users_sync"
  """
  update_neon_auth_users_sync_many(
    """updates to execute, in order"""
    updates: [neon_auth_users_sync_updates!]!
  ): [neon_auth_users_sync_mutation_response]

  """
  update data of the table: "notes"
  """
  update_notes(
    """sets the columns of the filtered rows to the given values"""
    _set: notes_set_input

    """filter the rows which have to be updated"""
    where: notes_bool_exp!
  ): notes_mutation_response

  """
  update single row of the table: "notes"
  """
  update_notes_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notes_set_input
    pk_columns: notes_pk_columns_input!
  ): notes

  """
  update multiples rows of table: "notes"
  """
  update_notes_many(
    """updates to execute, in order"""
    updates: [notes_updates!]!
  ): [notes_mutation_response]

  """
  update data of the table: "payroll_cycles"
  """
  update_payroll_cycles(
    """sets the columns of the filtered rows to the given values"""
    _set: payroll_cycles_set_input

    """filter the rows which have to be updated"""
    where: payroll_cycles_bool_exp!
  ): payroll_cycles_mutation_response

  """
  update single row of the table: "payroll_cycles"
  """
  update_payroll_cycles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: payroll_cycles_set_input
    pk_columns: payroll_cycles_pk_columns_input!
  ): payroll_cycles

  """
  update multiples rows of table: "payroll_cycles"
  """
  update_payroll_cycles_many(
    """updates to execute, in order"""
    updates: [payroll_cycles_updates!]!
  ): [payroll_cycles_mutation_response]

  """
  update data of the table: "payroll_date_types"
  """
  update_payroll_date_types(
    """sets the columns of the filtered rows to the given values"""
    _set: payroll_date_types_set_input

    """filter the rows which have to be updated"""
    where: payroll_date_types_bool_exp!
  ): payroll_date_types_mutation_response

  """
  update single row of the table: "payroll_date_types"
  """
  update_payroll_date_types_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: payroll_date_types_set_input
    pk_columns: payroll_date_types_pk_columns_input!
  ): payroll_date_types

  """
  update multiples rows of table: "payroll_date_types"
  """
  update_payroll_date_types_many(
    """updates to execute, in order"""
    updates: [payroll_date_types_updates!]!
  ): [payroll_date_types_mutation_response]

  """
  update data of the table: "payroll_dates"
  """
  update_payroll_dates(
    """sets the columns of the filtered rows to the given values"""
    _set: payroll_dates_set_input

    """filter the rows which have to be updated"""
    where: payroll_dates_bool_exp!
  ): payroll_dates_mutation_response

  """
  update single row of the table: "payroll_dates"
  """
  update_payroll_dates_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: payroll_dates_set_input
    pk_columns: payroll_dates_pk_columns_input!
  ): payroll_dates

  """
  update multiples rows of table: "payroll_dates"
  """
  update_payroll_dates_many(
    """updates to execute, in order"""
    updates: [payroll_dates_updates!]!
  ): [payroll_dates_mutation_response]

  """
  update data of the table: "payrolls"
  """
  update_payrolls(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payrolls_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payrolls_set_input

    """filter the rows which have to be updated"""
    where: payrolls_bool_exp!
  ): payrolls_mutation_response

  """
  update single row of the table: "payrolls"
  """
  update_payrolls_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payrolls_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payrolls_set_input
    pk_columns: payrolls_pk_columns_input!
  ): payrolls

  """
  update multiples rows of table: "payrolls"
  """
  update_payrolls_many(
    """updates to execute, in order"""
    updates: [payrolls_updates!]!
  ): [payrolls_mutation_response]

  """
  update data of the table: "permission_audit_log"
  """
  update_permission_audit_log(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: permission_audit_log_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: permission_audit_log_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: permission_audit_log_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: permission_audit_log_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: permission_audit_log_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: permission_audit_log_set_input

    """filter the rows which have to be updated"""
    where: permission_audit_log_bool_exp!
  ): permission_audit_log_mutation_response

  """
  update single row of the table: "permission_audit_log"
  """
  update_permission_audit_log_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: permission_audit_log_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: permission_audit_log_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: permission_audit_log_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: permission_audit_log_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: permission_audit_log_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: permission_audit_log_set_input
    pk_columns: permission_audit_log_pk_columns_input!
  ): permission_audit_log

  """
  update multiples rows of table: "permission_audit_log"
  """
  update_permission_audit_log_many(
    """updates to execute, in order"""
    updates: [permission_audit_log_updates!]!
  ): [permission_audit_log_mutation_response]

  """
  update data of the table: "permission_overrides"
  """
  update_permission_overrides(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: permission_overrides_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: permission_overrides_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: permission_overrides_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: permission_overrides_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: permission_overrides_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: permission_overrides_set_input

    """filter the rows which have to be updated"""
    where: permission_overrides_bool_exp!
  ): permission_overrides_mutation_response

  """
  update single row of the table: "permission_overrides"
  """
  update_permission_overrides_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: permission_overrides_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: permission_overrides_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: permission_overrides_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: permission_overrides_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: permission_overrides_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: permission_overrides_set_input
    pk_columns: permission_overrides_pk_columns_input!
  ): permission_overrides

  """
  update multiples rows of table: "permission_overrides"
  """
  update_permission_overrides_many(
    """updates to execute, in order"""
    updates: [permission_overrides_updates!]!
  ): [permission_overrides_mutation_response]

  """
  update data of the table: "users"
  """
  update_users(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "users"
  """
  update_users_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update multiples rows of table: "users"
  """
  update_users_many(
    """updates to execute, in order"""
    updates: [users_updates!]!
  ): [users_mutation_response]

  """
  update data of the table: "work_schedule"
  """
  update_work_schedule(
    """increments the numeric columns with given value of the filtered values"""
    _inc: work_schedule_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: work_schedule_set_input

    """filter the rows which have to be updated"""
    where: work_schedule_bool_exp!
  ): work_schedule_mutation_response

  """
  update single row of the table: "work_schedule"
  """
  update_work_schedule_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: work_schedule_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: work_schedule_set_input
    pk_columns: work_schedule_pk_columns_input!
  ): work_schedule

  """
  update multiples rows of table: "work_schedule"
  """
  update_work_schedule_many(
    """updates to execute, in order"""
    updates: [work_schedule_updates!]!
  ): [work_schedule_mutation_response]
}

"""
columns and relationships of "neon_auth.users_sync"
"""
type neon_auth_users_sync {
  """Timestamp when the user was created in the auth system"""
  created_at: timestamptz

  """Timestamp when the user was deleted in the auth system"""
  deleted_at: timestamptz

  """User's email address from authentication provider"""
  email: String

  """Unique identifier from the authentication provider"""
  id: String!

  """User's full name from authentication provider"""
  name: String

  """Complete JSON data from the authentication provider"""
  raw_json(
    """JSON select path"""
    path: String
  ): jsonb!

  """Timestamp when the user was last updated in the auth system"""
  updated_at: timestamptz
}

"""
aggregated selection of "neon_auth.users_sync"
"""
type neon_auth_users_sync_aggregate {
  aggregate: neon_auth_users_sync_aggregate_fields
  nodes: [neon_auth_users_sync!]!
}

"""
aggregate fields of "neon_auth.users_sync"
"""
type neon_auth_users_sync_aggregate_fields {
  count(columns: [neon_auth_users_sync_select_column!], distinct: Boolean): Int!
  max: neon_auth_users_sync_max_fields
  min: neon_auth_users_sync_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input neon_auth_users_sync_append_input {
  """Complete JSON data from the authentication provider"""
  raw_json: jsonb
}

"""
Boolean expression to filter rows from the table "neon_auth.users_sync". All fields are combined with a logical 'AND'.
"""
input neon_auth_users_sync_bool_exp {
  _and: [neon_auth_users_sync_bool_exp!]
  _not: neon_auth_users_sync_bool_exp
  _or: [neon_auth_users_sync_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  email: String_comparison_exp
  id: String_comparison_exp
  name: String_comparison_exp
  raw_json: jsonb_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "neon_auth.users_sync"
"""
enum neon_auth_users_sync_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  users_sync_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input neon_auth_users_sync_delete_at_path_input {
  """Complete JSON data from the authentication provider"""
  raw_json: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input neon_auth_users_sync_delete_elem_input {
  """Complete JSON data from the authentication provider"""
  raw_json: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input neon_auth_users_sync_delete_key_input {
  """Complete JSON data from the authentication provider"""
  raw_json: String
}

"""
input type for inserting data into table "neon_auth.users_sync"
"""
input neon_auth_users_sync_insert_input {
  """Timestamp when the user was deleted in the auth system"""
  deleted_at: timestamptz

  """Complete JSON data from the authentication provider"""
  raw_json: jsonb

  """Timestamp when the user was last updated in the auth system"""
  updated_at: timestamptz
}

"""aggregate max on columns"""
type neon_auth_users_sync_max_fields {
  """Timestamp when the user was created in the auth system"""
  created_at: timestamptz

  """Timestamp when the user was deleted in the auth system"""
  deleted_at: timestamptz

  """User's email address from authentication provider"""
  email: String

  """Unique identifier from the authentication provider"""
  id: String

  """User's full name from authentication provider"""
  name: String

  """Timestamp when the user was last updated in the auth system"""
  updated_at: timestamptz
}

"""aggregate min on columns"""
type neon_auth_users_sync_min_fields {
  """Timestamp when the user was created in the auth system"""
  created_at: timestamptz

  """Timestamp when the user was deleted in the auth system"""
  deleted_at: timestamptz

  """User's email address from authentication provider"""
  email: String

  """Unique identifier from the authentication provider"""
  id: String

  """User's full name from authentication provider"""
  name: String

  """Timestamp when the user was last updated in the auth system"""
  updated_at: timestamptz
}

"""
response of any mutation on the table "neon_auth.users_sync"
"""
type neon_auth_users_sync_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [neon_auth_users_sync!]!
}

"""
on_conflict condition type for table "neon_auth.users_sync"
"""
input neon_auth_users_sync_on_conflict {
  constraint: neon_auth_users_sync_constraint!
  update_columns: [neon_auth_users_sync_update_column!]! = []
  where: neon_auth_users_sync_bool_exp
}

"""Ordering options when selecting data from "neon_auth.users_sync"."""
input neon_auth_users_sync_order_by {
  created_at: order_by
  deleted_at: order_by
  email: order_by
  id: order_by
  name: order_by
  raw_json: order_by
  updated_at: order_by
}

"""primary key columns input for table: neon_auth.users_sync"""
input neon_auth_users_sync_pk_columns_input {
  """Unique identifier from the authentication provider"""
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input neon_auth_users_sync_prepend_input {
  """Complete JSON data from the authentication provider"""
  raw_json: jsonb
}

"""
select columns of table "neon_auth.users_sync"
"""
enum neon_auth_users_sync_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  name

  """column name"""
  raw_json

  """column name"""
  updated_at
}

"""
input type for updating data in table "neon_auth.users_sync"
"""
input neon_auth_users_sync_set_input {
  """Timestamp when the user was deleted in the auth system"""
  deleted_at: timestamptz

  """Complete JSON data from the authentication provider"""
  raw_json: jsonb

  """Timestamp when the user was last updated in the auth system"""
  updated_at: timestamptz
}

"""
Streaming cursor of the table "neon_auth_users_sync"
"""
input neon_auth_users_sync_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: neon_auth_users_sync_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input neon_auth_users_sync_stream_cursor_value_input {
  """Timestamp when the user was created in the auth system"""
  created_at: timestamptz

  """Timestamp when the user was deleted in the auth system"""
  deleted_at: timestamptz

  """User's email address from authentication provider"""
  email: String

  """Unique identifier from the authentication provider"""
  id: String

  """User's full name from authentication provider"""
  name: String

  """Complete JSON data from the authentication provider"""
  raw_json: jsonb

  """Timestamp when the user was last updated in the auth system"""
  updated_at: timestamptz
}

"""
update columns of table "neon_auth.users_sync"
"""
enum neon_auth_users_sync_update_column {
  """column name"""
  deleted_at

  """column name"""
  raw_json

  """column name"""
  updated_at
}

input neon_auth_users_sync_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: neon_auth_users_sync_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: neon_auth_users_sync_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: neon_auth_users_sync_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: neon_auth_users_sync_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: neon_auth_users_sync_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: neon_auth_users_sync_set_input

  """filter the rows which have to be updated"""
  where: neon_auth_users_sync_bool_exp!
}

"""
columns and relationships of "notes"
"""
type notes {
  """Content of the note"""
  content: String!

  """Timestamp when the note was created"""
  created_at: timestamp

  """Identifier of the entity this note is attached to"""
  entity_id: uuid!

  """Type of entity this note is attached to (client, payroll, etc.)"""
  entity_type: String!

  """Unique identifier for the note"""
  id: uuid!

  """Whether the note is flagged as important"""
  is_important: Boolean

  """An array relationship"""
  notes_by_client(
    """distinct select on columns"""
    distinct_on: [clients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clients_order_by!]

    """filter the rows returned"""
    where: clients_bool_exp
  ): [clients!]!

  """An aggregate relationship"""
  notes_by_client_aggregate(
    """distinct select on columns"""
    distinct_on: [clients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clients_order_by!]

    """filter the rows returned"""
    where: clients_bool_exp
  ): clients_aggregate!

  """An array relationship"""
  notes_by_payroll(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """An aggregate relationship"""
  notes_by_payroll_aggregate(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): payrolls_aggregate!

  """Timestamp when the note was last updated"""
  updated_at: timestamp

  """An object relationship"""
  user: users

  """User who created the note"""
  user_id: uuid
}

"""
aggregated selection of "notes"
"""
type notes_aggregate {
  aggregate: notes_aggregate_fields
  nodes: [notes!]!
}

input notes_aggregate_bool_exp {
  bool_and: notes_aggregate_bool_exp_bool_and
  bool_or: notes_aggregate_bool_exp_bool_or
  count: notes_aggregate_bool_exp_count
}

input notes_aggregate_bool_exp_bool_and {
  arguments: notes_select_column_notes_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: notes_bool_exp
  predicate: Boolean_comparison_exp!
}

input notes_aggregate_bool_exp_bool_or {
  arguments: notes_select_column_notes_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: notes_bool_exp
  predicate: Boolean_comparison_exp!
}

input notes_aggregate_bool_exp_count {
  arguments: [notes_select_column!]
  distinct: Boolean
  filter: notes_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "notes"
"""
type notes_aggregate_fields {
  count(columns: [notes_select_column!], distinct: Boolean): Int!
  max: notes_max_fields
  min: notes_min_fields
}

"""
order by aggregate values of table "notes"
"""
input notes_aggregate_order_by {
  count: order_by
  max: notes_max_order_by
  min: notes_min_order_by
}

"""
input type for inserting array relation for remote table "notes"
"""
input notes_arr_rel_insert_input {
  data: [notes_insert_input!]!

  """upsert condition"""
  on_conflict: notes_on_conflict
}

"""
Boolean expression to filter rows from the table "notes". All fields are combined with a logical 'AND'.
"""
input notes_bool_exp {
  _and: [notes_bool_exp!]
  _not: notes_bool_exp
  _or: [notes_bool_exp!]
  content: String_comparison_exp
  created_at: timestamp_comparison_exp
  entity_id: uuid_comparison_exp
  entity_type: String_comparison_exp
  id: uuid_comparison_exp
  is_important: Boolean_comparison_exp
  notes_by_client: clients_bool_exp
  notes_by_client_aggregate: clients_aggregate_bool_exp
  notes_by_payroll: payrolls_bool_exp
  notes_by_payroll_aggregate: payrolls_aggregate_bool_exp
  updated_at: timestamp_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "notes"
"""
enum notes_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notes_pkey
}

"""
input type for inserting data into table "notes"
"""
input notes_insert_input {
  """Content of the note"""
  content: String

  """Timestamp when the note was created"""
  created_at: timestamp

  """Identifier of the entity this note is attached to"""
  entity_id: uuid

  """Type of entity this note is attached to (client, payroll, etc.)"""
  entity_type: String

  """Unique identifier for the note"""
  id: uuid

  """Whether the note is flagged as important"""
  is_important: Boolean
  notes_by_client: clients_arr_rel_insert_input
  notes_by_payroll: payrolls_arr_rel_insert_input

  """Timestamp when the note was last updated"""
  updated_at: timestamp
  user: users_obj_rel_insert_input

  """User who created the note"""
  user_id: uuid
}

"""aggregate max on columns"""
type notes_max_fields {
  """Content of the note"""
  content: String

  """Timestamp when the note was created"""
  created_at: timestamp

  """Identifier of the entity this note is attached to"""
  entity_id: uuid

  """Type of entity this note is attached to (client, payroll, etc.)"""
  entity_type: String

  """Unique identifier for the note"""
  id: uuid

  """Timestamp when the note was last updated"""
  updated_at: timestamp

  """User who created the note"""
  user_id: uuid
}

"""
order by max() on columns of table "notes"
"""
input notes_max_order_by {
  """Content of the note"""
  content: order_by

  """Timestamp when the note was created"""
  created_at: order_by

  """Identifier of the entity this note is attached to"""
  entity_id: order_by

  """Type of entity this note is attached to (client, payroll, etc.)"""
  entity_type: order_by

  """Unique identifier for the note"""
  id: order_by

  """Timestamp when the note was last updated"""
  updated_at: order_by

  """User who created the note"""
  user_id: order_by
}

"""aggregate min on columns"""
type notes_min_fields {
  """Content of the note"""
  content: String

  """Timestamp when the note was created"""
  created_at: timestamp

  """Identifier of the entity this note is attached to"""
  entity_id: uuid

  """Type of entity this note is attached to (client, payroll, etc.)"""
  entity_type: String

  """Unique identifier for the note"""
  id: uuid

  """Timestamp when the note was last updated"""
  updated_at: timestamp

  """User who created the note"""
  user_id: uuid
}

"""
order by min() on columns of table "notes"
"""
input notes_min_order_by {
  """Content of the note"""
  content: order_by

  """Timestamp when the note was created"""
  created_at: order_by

  """Identifier of the entity this note is attached to"""
  entity_id: order_by

  """Type of entity this note is attached to (client, payroll, etc.)"""
  entity_type: order_by

  """Unique identifier for the note"""
  id: order_by

  """Timestamp when the note was last updated"""
  updated_at: order_by

  """User who created the note"""
  user_id: order_by
}

"""
response of any mutation on the table "notes"
"""
type notes_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notes!]!
}

"""
on_conflict condition type for table "notes"
"""
input notes_on_conflict {
  constraint: notes_constraint!
  update_columns: [notes_update_column!]! = []
  where: notes_bool_exp
}

"""Ordering options when selecting data from "notes"."""
input notes_order_by {
  content: order_by
  created_at: order_by
  entity_id: order_by
  entity_type: order_by
  id: order_by
  is_important: order_by
  notes_by_client_aggregate: clients_aggregate_order_by
  notes_by_payroll_aggregate: payrolls_aggregate_order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: notes"""
input notes_pk_columns_input {
  """Unique identifier for the note"""
  id: uuid!
}

"""
select columns of table "notes"
"""
enum notes_select_column {
  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  entity_id

  """column name"""
  entity_type

  """column name"""
  id

  """column name"""
  is_important

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
select "notes_aggregate_bool_exp_bool_and_arguments_columns" columns of table "notes"
"""
enum notes_select_column_notes_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_important
}

"""
select "notes_aggregate_bool_exp_bool_or_arguments_columns" columns of table "notes"
"""
enum notes_select_column_notes_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_important
}

"""
input type for updating data in table "notes"
"""
input notes_set_input {
  """Content of the note"""
  content: String

  """Timestamp when the note was created"""
  created_at: timestamp

  """Identifier of the entity this note is attached to"""
  entity_id: uuid

  """Type of entity this note is attached to (client, payroll, etc.)"""
  entity_type: String

  """Unique identifier for the note"""
  id: uuid

  """Whether the note is flagged as important"""
  is_important: Boolean

  """Timestamp when the note was last updated"""
  updated_at: timestamp

  """User who created the note"""
  user_id: uuid
}

"""
Streaming cursor of the table "notes"
"""
input notes_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notes_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notes_stream_cursor_value_input {
  """Content of the note"""
  content: String

  """Timestamp when the note was created"""
  created_at: timestamp

  """Identifier of the entity this note is attached to"""
  entity_id: uuid

  """Type of entity this note is attached to (client, payroll, etc.)"""
  entity_type: String

  """Unique identifier for the note"""
  id: uuid

  """Whether the note is flagged as important"""
  is_important: Boolean

  """Timestamp when the note was last updated"""
  updated_at: timestamp

  """User who created the note"""
  user_id: uuid
}

"""
update columns of table "notes"
"""
enum notes_update_column {
  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  entity_id

  """column name"""
  entity_type

  """column name"""
  id

  """column name"""
  is_important

  """column name"""
  updated_at

  """column name"""
  user_id
}

input notes_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notes_set_input

  """filter the rows which have to be updated"""
  where: notes_bool_exp!
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

scalar payroll_cycle_type

"""
Boolean expression to compare columns of type "payroll_cycle_type". All fields are combined with logical 'AND'.
"""
input payroll_cycle_type_comparison_exp {
  _eq: payroll_cycle_type
  _gt: payroll_cycle_type
  _gte: payroll_cycle_type
  _in: [payroll_cycle_type!]
  _is_null: Boolean
  _lt: payroll_cycle_type
  _lte: payroll_cycle_type
  _neq: payroll_cycle_type
  _nin: [payroll_cycle_type!]
}

"""
columns and relationships of "payroll_cycles"
"""
type payroll_cycles {
  """An array relationship"""
  adjustment_rules(
    """distinct select on columns"""
    distinct_on: [adjustment_rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [adjustment_rules_order_by!]

    """filter the rows returned"""
    where: adjustment_rules_bool_exp
  ): [adjustment_rules!]!

  """An aggregate relationship"""
  adjustment_rules_aggregate(
    """distinct select on columns"""
    distinct_on: [adjustment_rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [adjustment_rules_order_by!]

    """filter the rows returned"""
    where: adjustment_rules_bool_exp
  ): adjustment_rules_aggregate!

  """Timestamp when the cycle was created"""
  created_at: timestamptz

  """Detailed description of the payroll cycle"""
  description: String

  """Unique identifier for the payroll cycle"""
  id: uuid!

  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type!

  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """An aggregate relationship"""
  payrolls_aggregate(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): payrolls_aggregate!

  """Timestamp when the cycle was last updated"""
  updated_at: timestamptz
}

"""
aggregated selection of "payroll_cycles"
"""
type payroll_cycles_aggregate {
  aggregate: payroll_cycles_aggregate_fields
  nodes: [payroll_cycles!]!
}

"""
aggregate fields of "payroll_cycles"
"""
type payroll_cycles_aggregate_fields {
  count(columns: [payroll_cycles_select_column!], distinct: Boolean): Int!
  max: payroll_cycles_max_fields
  min: payroll_cycles_min_fields
}

"""
Boolean expression to filter rows from the table "payroll_cycles". All fields are combined with a logical 'AND'.
"""
input payroll_cycles_bool_exp {
  _and: [payroll_cycles_bool_exp!]
  _not: payroll_cycles_bool_exp
  _or: [payroll_cycles_bool_exp!]
  adjustment_rules: adjustment_rules_bool_exp
  adjustment_rules_aggregate: adjustment_rules_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: payroll_cycle_type_comparison_exp
  payrolls: payrolls_bool_exp
  payrolls_aggregate: payrolls_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "payroll_cycles"
"""
enum payroll_cycles_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  payroll_cycles_name_key

  """
  unique or primary key constraint on columns "id"
  """
  payroll_cycles_pkey
}

"""
input type for inserting data into table "payroll_cycles"
"""
input payroll_cycles_insert_input {
  adjustment_rules: adjustment_rules_arr_rel_insert_input

  """Timestamp when the cycle was created"""
  created_at: timestamptz

  """Detailed description of the payroll cycle"""
  description: String

  """Unique identifier for the payroll cycle"""
  id: uuid

  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type
  payrolls: payrolls_arr_rel_insert_input

  """Timestamp when the cycle was last updated"""
  updated_at: timestamptz
}

"""aggregate max on columns"""
type payroll_cycles_max_fields {
  """Timestamp when the cycle was created"""
  created_at: timestamptz

  """Detailed description of the payroll cycle"""
  description: String

  """Unique identifier for the payroll cycle"""
  id: uuid

  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type

  """Timestamp when the cycle was last updated"""
  updated_at: timestamptz
}

"""aggregate min on columns"""
type payroll_cycles_min_fields {
  """Timestamp when the cycle was created"""
  created_at: timestamptz

  """Detailed description of the payroll cycle"""
  description: String

  """Unique identifier for the payroll cycle"""
  id: uuid

  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type

  """Timestamp when the cycle was last updated"""
  updated_at: timestamptz
}

"""
response of any mutation on the table "payroll_cycles"
"""
type payroll_cycles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payroll_cycles!]!
}

"""
input type for inserting object relation for remote table "payroll_cycles"
"""
input payroll_cycles_obj_rel_insert_input {
  data: payroll_cycles_insert_input!

  """upsert condition"""
  on_conflict: payroll_cycles_on_conflict
}

"""
on_conflict condition type for table "payroll_cycles"
"""
input payroll_cycles_on_conflict {
  constraint: payroll_cycles_constraint!
  update_columns: [payroll_cycles_update_column!]! = []
  where: payroll_cycles_bool_exp
}

"""Ordering options when selecting data from "payroll_cycles"."""
input payroll_cycles_order_by {
  adjustment_rules_aggregate: adjustment_rules_aggregate_order_by
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  payrolls_aggregate: payrolls_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: payroll_cycles"""
input payroll_cycles_pk_columns_input {
  """Unique identifier for the payroll cycle"""
  id: uuid!
}

"""
select columns of table "payroll_cycles"
"""
enum payroll_cycles_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "payroll_cycles"
"""
input payroll_cycles_set_input {
  """Timestamp when the cycle was created"""
  created_at: timestamptz

  """Detailed description of the payroll cycle"""
  description: String

  """Unique identifier for the payroll cycle"""
  id: uuid

  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type

  """Timestamp when the cycle was last updated"""
  updated_at: timestamptz
}

"""
Streaming cursor of the table "payroll_cycles"
"""
input payroll_cycles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payroll_cycles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payroll_cycles_stream_cursor_value_input {
  """Timestamp when the cycle was created"""
  created_at: timestamptz

  """Detailed description of the payroll cycle"""
  description: String

  """Unique identifier for the payroll cycle"""
  id: uuid

  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type

  """Timestamp when the cycle was last updated"""
  updated_at: timestamptz
}

"""
update columns of table "payroll_cycles"
"""
enum payroll_cycles_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input payroll_cycles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: payroll_cycles_set_input

  """filter the rows which have to be updated"""
  where: payroll_cycles_bool_exp!
}

scalar payroll_date_type

"""
Boolean expression to compare columns of type "payroll_date_type". All fields are combined with logical 'AND'.
"""
input payroll_date_type_comparison_exp {
  _eq: payroll_date_type
  _gt: payroll_date_type
  _gte: payroll_date_type
  _in: [payroll_date_type!]
  _is_null: Boolean
  _lt: payroll_date_type
  _lte: payroll_date_type
  _neq: payroll_date_type
  _nin: [payroll_date_type!]
}

"""
columns and relationships of "payroll_date_types"
"""
type payroll_date_types {
  """An array relationship"""
  adjustment_rules(
    """distinct select on columns"""
    distinct_on: [adjustment_rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [adjustment_rules_order_by!]

    """filter the rows returned"""
    where: adjustment_rules_bool_exp
  ): [adjustment_rules!]!

  """An aggregate relationship"""
  adjustment_rules_aggregate(
    """distinct select on columns"""
    distinct_on: [adjustment_rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [adjustment_rules_order_by!]

    """filter the rows returned"""
    where: adjustment_rules_bool_exp
  ): adjustment_rules_aggregate!

  """Timestamp when the date type was created"""
  created_at: timestamptz

  """Detailed description of how this date type works"""
  description: String

  """Unique identifier for the payroll date type"""
  id: uuid!

  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type!

  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """An aggregate relationship"""
  payrolls_aggregate(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): payrolls_aggregate!

  """Timestamp when the date type was last updated"""
  updated_at: timestamptz
}

"""
aggregated selection of "payroll_date_types"
"""
type payroll_date_types_aggregate {
  aggregate: payroll_date_types_aggregate_fields
  nodes: [payroll_date_types!]!
}

"""
aggregate fields of "payroll_date_types"
"""
type payroll_date_types_aggregate_fields {
  count(columns: [payroll_date_types_select_column!], distinct: Boolean): Int!
  max: payroll_date_types_max_fields
  min: payroll_date_types_min_fields
}

"""
Boolean expression to filter rows from the table "payroll_date_types". All fields are combined with a logical 'AND'.
"""
input payroll_date_types_bool_exp {
  _and: [payroll_date_types_bool_exp!]
  _not: payroll_date_types_bool_exp
  _or: [payroll_date_types_bool_exp!]
  adjustment_rules: adjustment_rules_bool_exp
  adjustment_rules_aggregate: adjustment_rules_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: payroll_date_type_comparison_exp
  payrolls: payrolls_bool_exp
  payrolls_aggregate: payrolls_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "payroll_date_types"
"""
enum payroll_date_types_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  payroll_date_types_name_key

  """
  unique or primary key constraint on columns "id"
  """
  payroll_date_types_pkey
}

"""
input type for inserting data into table "payroll_date_types"
"""
input payroll_date_types_insert_input {
  adjustment_rules: adjustment_rules_arr_rel_insert_input

  """Timestamp when the date type was created"""
  created_at: timestamptz

  """Detailed description of how this date type works"""
  description: String

  """Unique identifier for the payroll date type"""
  id: uuid

  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type
  payrolls: payrolls_arr_rel_insert_input

  """Timestamp when the date type was last updated"""
  updated_at: timestamptz
}

"""aggregate max on columns"""
type payroll_date_types_max_fields {
  """Timestamp when the date type was created"""
  created_at: timestamptz

  """Detailed description of how this date type works"""
  description: String

  """Unique identifier for the payroll date type"""
  id: uuid

  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type

  """Timestamp when the date type was last updated"""
  updated_at: timestamptz
}

"""aggregate min on columns"""
type payroll_date_types_min_fields {
  """Timestamp when the date type was created"""
  created_at: timestamptz

  """Detailed description of how this date type works"""
  description: String

  """Unique identifier for the payroll date type"""
  id: uuid

  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type

  """Timestamp when the date type was last updated"""
  updated_at: timestamptz
}

"""
response of any mutation on the table "payroll_date_types"
"""
type payroll_date_types_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payroll_date_types!]!
}

"""
input type for inserting object relation for remote table "payroll_date_types"
"""
input payroll_date_types_obj_rel_insert_input {
  data: payroll_date_types_insert_input!

  """upsert condition"""
  on_conflict: payroll_date_types_on_conflict
}

"""
on_conflict condition type for table "payroll_date_types"
"""
input payroll_date_types_on_conflict {
  constraint: payroll_date_types_constraint!
  update_columns: [payroll_date_types_update_column!]! = []
  where: payroll_date_types_bool_exp
}

"""Ordering options when selecting data from "payroll_date_types"."""
input payroll_date_types_order_by {
  adjustment_rules_aggregate: adjustment_rules_aggregate_order_by
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  payrolls_aggregate: payrolls_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: payroll_date_types"""
input payroll_date_types_pk_columns_input {
  """Unique identifier for the payroll date type"""
  id: uuid!
}

"""
select columns of table "payroll_date_types"
"""
enum payroll_date_types_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "payroll_date_types"
"""
input payroll_date_types_set_input {
  """Timestamp when the date type was created"""
  created_at: timestamptz

  """Detailed description of how this date type works"""
  description: String

  """Unique identifier for the payroll date type"""
  id: uuid

  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type

  """Timestamp when the date type was last updated"""
  updated_at: timestamptz
}

"""
Streaming cursor of the table "payroll_date_types"
"""
input payroll_date_types_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payroll_date_types_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payroll_date_types_stream_cursor_value_input {
  """Timestamp when the date type was created"""
  created_at: timestamptz

  """Detailed description of how this date type works"""
  description: String

  """Unique identifier for the payroll date type"""
  id: uuid

  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type

  """Timestamp when the date type was last updated"""
  updated_at: timestamptz
}

"""
update columns of table "payroll_date_types"
"""
enum payroll_date_types_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input payroll_date_types_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: payroll_date_types_set_input

  """filter the rows which have to be updated"""
  where: payroll_date_types_bool_exp!
}

"""
columns and relationships of "payroll_dates"
"""
type payroll_dates {
  """Final EFT date after holiday and weekend adjustments"""
  adjusted_eft_date: date!

  """Timestamp when the date record was created"""
  created_at: timestamptz

  """Unique identifier for the payroll date"""
  id: uuid!

  """Additional notes about this payroll date"""
  notes: String

  """Originally calculated EFT date before adjustments"""
  original_eft_date: date!

  """An object relationship"""
  payroll: payrolls!

  """Reference to the payroll this date belongs to"""
  payroll_id: uuid!

  """Date when payroll processing must be completed"""
  processing_date: date!

  """Timestamp when the date record was last updated"""
  updated_at: timestamptz
}

"""
aggregated selection of "payroll_dates"
"""
type payroll_dates_aggregate {
  aggregate: payroll_dates_aggregate_fields
  nodes: [payroll_dates!]!
}

input payroll_dates_aggregate_bool_exp {
  count: payroll_dates_aggregate_bool_exp_count
}

input payroll_dates_aggregate_bool_exp_count {
  arguments: [payroll_dates_select_column!]
  distinct: Boolean
  filter: payroll_dates_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "payroll_dates"
"""
type payroll_dates_aggregate_fields {
  count(columns: [payroll_dates_select_column!], distinct: Boolean): Int!
  max: payroll_dates_max_fields
  min: payroll_dates_min_fields
}

"""
order by aggregate values of table "payroll_dates"
"""
input payroll_dates_aggregate_order_by {
  count: order_by
  max: payroll_dates_max_order_by
  min: payroll_dates_min_order_by
}

"""
input type for inserting array relation for remote table "payroll_dates"
"""
input payroll_dates_arr_rel_insert_input {
  data: [payroll_dates_insert_input!]!

  """upsert condition"""
  on_conflict: payroll_dates_on_conflict
}

"""
Boolean expression to filter rows from the table "payroll_dates". All fields are combined with a logical 'AND'.
"""
input payroll_dates_bool_exp {
  _and: [payroll_dates_bool_exp!]
  _not: payroll_dates_bool_exp
  _or: [payroll_dates_bool_exp!]
  adjusted_eft_date: date_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  notes: String_comparison_exp
  original_eft_date: date_comparison_exp
  payroll: payrolls_bool_exp
  payroll_id: uuid_comparison_exp
  processing_date: date_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "payroll_dates"
"""
enum payroll_dates_constraint {
  """
  unique or primary key constraint on columns "original_eft_date", "payroll_id"
  """
  idx_unique_payroll_date

  """
  unique or primary key constraint on columns "id"
  """
  payroll_dates_pkey
}

"""
input type for inserting data into table "payroll_dates"
"""
input payroll_dates_insert_input {
  """Final EFT date after holiday and weekend adjustments"""
  adjusted_eft_date: date

  """Timestamp when the date record was created"""
  created_at: timestamptz

  """Unique identifier for the payroll date"""
  id: uuid

  """Additional notes about this payroll date"""
  notes: String

  """Originally calculated EFT date before adjustments"""
  original_eft_date: date
  payroll: payrolls_obj_rel_insert_input

  """Reference to the payroll this date belongs to"""
  payroll_id: uuid

  """Date when payroll processing must be completed"""
  processing_date: date

  """Timestamp when the date record was last updated"""
  updated_at: timestamptz
}

"""aggregate max on columns"""
type payroll_dates_max_fields {
  """Final EFT date after holiday and weekend adjustments"""
  adjusted_eft_date: date

  """Timestamp when the date record was created"""
  created_at: timestamptz

  """Unique identifier for the payroll date"""
  id: uuid

  """Additional notes about this payroll date"""
  notes: String

  """Originally calculated EFT date before adjustments"""
  original_eft_date: date

  """Reference to the payroll this date belongs to"""
  payroll_id: uuid

  """Date when payroll processing must be completed"""
  processing_date: date

  """Timestamp when the date record was last updated"""
  updated_at: timestamptz
}

"""
order by max() on columns of table "payroll_dates"
"""
input payroll_dates_max_order_by {
  """Final EFT date after holiday and weekend adjustments"""
  adjusted_eft_date: order_by

  """Timestamp when the date record was created"""
  created_at: order_by

  """Unique identifier for the payroll date"""
  id: order_by

  """Additional notes about this payroll date"""
  notes: order_by

  """Originally calculated EFT date before adjustments"""
  original_eft_date: order_by

  """Reference to the payroll this date belongs to"""
  payroll_id: order_by

  """Date when payroll processing must be completed"""
  processing_date: order_by

  """Timestamp when the date record was last updated"""
  updated_at: order_by
}

"""aggregate min on columns"""
type payroll_dates_min_fields {
  """Final EFT date after holiday and weekend adjustments"""
  adjusted_eft_date: date

  """Timestamp when the date record was created"""
  created_at: timestamptz

  """Unique identifier for the payroll date"""
  id: uuid

  """Additional notes about this payroll date"""
  notes: String

  """Originally calculated EFT date before adjustments"""
  original_eft_date: date

  """Reference to the payroll this date belongs to"""
  payroll_id: uuid

  """Date when payroll processing must be completed"""
  processing_date: date

  """Timestamp when the date record was last updated"""
  updated_at: timestamptz
}

"""
order by min() on columns of table "payroll_dates"
"""
input payroll_dates_min_order_by {
  """Final EFT date after holiday and weekend adjustments"""
  adjusted_eft_date: order_by

  """Timestamp when the date record was created"""
  created_at: order_by

  """Unique identifier for the payroll date"""
  id: order_by

  """Additional notes about this payroll date"""
  notes: order_by

  """Originally calculated EFT date before adjustments"""
  original_eft_date: order_by

  """Reference to the payroll this date belongs to"""
  payroll_id: order_by

  """Date when payroll processing must be completed"""
  processing_date: order_by

  """Timestamp when the date record was last updated"""
  updated_at: order_by
}

"""
response of any mutation on the table "payroll_dates"
"""
type payroll_dates_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payroll_dates!]!
}

"""
on_conflict condition type for table "payroll_dates"
"""
input payroll_dates_on_conflict {
  constraint: payroll_dates_constraint!
  update_columns: [payroll_dates_update_column!]! = []
  where: payroll_dates_bool_exp
}

"""Ordering options when selecting data from "payroll_dates"."""
input payroll_dates_order_by {
  adjusted_eft_date: order_by
  created_at: order_by
  id: order_by
  notes: order_by
  original_eft_date: order_by
  payroll: payrolls_order_by
  payroll_id: order_by
  processing_date: order_by
  updated_at: order_by
}

"""primary key columns input for table: payroll_dates"""
input payroll_dates_pk_columns_input {
  """Unique identifier for the payroll date"""
  id: uuid!
}

"""
select columns of table "payroll_dates"
"""
enum payroll_dates_select_column {
  """column name"""
  adjusted_eft_date

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  notes

  """column name"""
  original_eft_date

  """column name"""
  payroll_id

  """column name"""
  processing_date

  """column name"""
  updated_at
}

"""
input type for updating data in table "payroll_dates"
"""
input payroll_dates_set_input {
  """Final EFT date after holiday and weekend adjustments"""
  adjusted_eft_date: date

  """Timestamp when the date record was created"""
  created_at: timestamptz

  """Unique identifier for the payroll date"""
  id: uuid

  """Additional notes about this payroll date"""
  notes: String

  """Originally calculated EFT date before adjustments"""
  original_eft_date: date

  """Reference to the payroll this date belongs to"""
  payroll_id: uuid

  """Date when payroll processing must be completed"""
  processing_date: date

  """Timestamp when the date record was last updated"""
  updated_at: timestamptz
}

"""
Streaming cursor of the table "payroll_dates"
"""
input payroll_dates_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payroll_dates_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payroll_dates_stream_cursor_value_input {
  """Final EFT date after holiday and weekend adjustments"""
  adjusted_eft_date: date

  """Timestamp when the date record was created"""
  created_at: timestamptz

  """Unique identifier for the payroll date"""
  id: uuid

  """Additional notes about this payroll date"""
  notes: String

  """Originally calculated EFT date before adjustments"""
  original_eft_date: date

  """Reference to the payroll this date belongs to"""
  payroll_id: uuid

  """Date when payroll processing must be completed"""
  processing_date: date

  """Timestamp when the date record was last updated"""
  updated_at: timestamptz
}

"""
update columns of table "payroll_dates"
"""
enum payroll_dates_update_column {
  """column name"""
  adjusted_eft_date

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  notes

  """column name"""
  original_eft_date

  """column name"""
  payroll_id

  """column name"""
  processing_date

  """column name"""
  updated_at
}

input payroll_dates_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: payroll_dates_set_input

  """filter the rows which have to be updated"""
  where: payroll_dates_bool_exp!
}

scalar payroll_status

"""
Boolean expression to compare columns of type "payroll_status". All fields are combined with logical 'AND'.
"""
input payroll_status_comparison_exp {
  _eq: payroll_status
  _gt: payroll_status
  _gte: payroll_status
  _in: [payroll_status!]
  _is_null: Boolean
  _lt: payroll_status
  _lte: payroll_status
  _neq: payroll_status
  _nin: [payroll_status!]
}

"""
columns and relationships of "payrolls"
"""
type payrolls {
  """Backup consultant for this payroll"""
  backup_consultant_user_id: uuid

  """An object relationship"""
  client: clients!

  """Reference to the client this payroll belongs to"""
  client_id: uuid!

  """Timestamp when the payroll was created"""
  created_at: timestamptz

  """Reference to the payroll cycle"""
  cycle_id: uuid!

  """Reference to the payroll date type"""
  date_type_id: uuid!

  """Specific value for date calculation (e.g., day of month)"""
  date_value: Int

  """Number of employees in this payroll"""
  employee_count: Int

  """The date when the payroll went live in the system"""
  go_live_date: date

  """Unique identifier for the payroll"""
  id: uuid!

  """Manager overseeing this payroll"""
  manager_user_id: uuid

  """Name of the payroll"""
  name: String!

  """An object relationship"""
  payroll_cycle: payroll_cycles!

  """An object relationship"""
  payroll_date_type: payroll_date_types!

  """An array relationship"""
  payroll_dates(
    """distinct select on columns"""
    distinct_on: [payroll_dates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_dates_order_by!]

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): [payroll_dates!]!

  """An aggregate relationship"""
  payroll_dates_aggregate(
    """distinct select on columns"""
    distinct_on: [payroll_dates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_dates_order_by!]

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): payroll_dates_aggregate!

  """External payroll system used for this client"""
  payroll_system: String

  """Primary consultant responsible for this payroll"""
  primary_consultant_user_id: uuid

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Int!

  """Number of hours required to process this payroll"""
  processing_time: Int!

  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status!

  """Timestamp when the payroll was last updated"""
  updated_at: timestamptz

  """An object relationship"""
  userByBackupConsultantUserId: users

  """An object relationship"""
  userByManagerUserId: users

  """An object relationship"""
  userByPrimaryConsultantUserId: users
}

"""
aggregated selection of "payrolls"
"""
type payrolls_aggregate {
  aggregate: payrolls_aggregate_fields
  nodes: [payrolls!]!
}

input payrolls_aggregate_bool_exp {
  count: payrolls_aggregate_bool_exp_count
}

input payrolls_aggregate_bool_exp_count {
  arguments: [payrolls_select_column!]
  distinct: Boolean
  filter: payrolls_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "payrolls"
"""
type payrolls_aggregate_fields {
  avg: payrolls_avg_fields
  count(columns: [payrolls_select_column!], distinct: Boolean): Int!
  max: payrolls_max_fields
  min: payrolls_min_fields
  stddev: payrolls_stddev_fields
  stddev_pop: payrolls_stddev_pop_fields
  stddev_samp: payrolls_stddev_samp_fields
  sum: payrolls_sum_fields
  var_pop: payrolls_var_pop_fields
  var_samp: payrolls_var_samp_fields
  variance: payrolls_variance_fields
}

"""
order by aggregate values of table "payrolls"
"""
input payrolls_aggregate_order_by {
  avg: payrolls_avg_order_by
  count: order_by
  max: payrolls_max_order_by
  min: payrolls_min_order_by
  stddev: payrolls_stddev_order_by
  stddev_pop: payrolls_stddev_pop_order_by
  stddev_samp: payrolls_stddev_samp_order_by
  sum: payrolls_sum_order_by
  var_pop: payrolls_var_pop_order_by
  var_samp: payrolls_var_samp_order_by
  variance: payrolls_variance_order_by
}

"""
input type for inserting array relation for remote table "payrolls"
"""
input payrolls_arr_rel_insert_input {
  data: [payrolls_insert_input!]!

  """upsert condition"""
  on_conflict: payrolls_on_conflict
}

"""aggregate avg on columns"""
type payrolls_avg_fields {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: Float

  """Number of employees in this payroll"""
  employee_count: Float

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Float

  """Number of hours required to process this payroll"""
  processing_time: Float
}

"""
order by avg() on columns of table "payrolls"
"""
input payrolls_avg_order_by {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: order_by

  """Number of employees in this payroll"""
  employee_count: order_by

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: order_by

  """Number of hours required to process this payroll"""
  processing_time: order_by
}

"""
Boolean expression to filter rows from the table "payrolls". All fields are combined with a logical 'AND'.
"""
input payrolls_bool_exp {
  _and: [payrolls_bool_exp!]
  _not: payrolls_bool_exp
  _or: [payrolls_bool_exp!]
  backup_consultant_user_id: uuid_comparison_exp
  client: clients_bool_exp
  client_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  cycle_id: uuid_comparison_exp
  date_type_id: uuid_comparison_exp
  date_value: Int_comparison_exp
  employee_count: Int_comparison_exp
  go_live_date: date_comparison_exp
  id: uuid_comparison_exp
  manager_user_id: uuid_comparison_exp
  name: String_comparison_exp
  payroll_cycle: payroll_cycles_bool_exp
  payroll_date_type: payroll_date_types_bool_exp
  payroll_dates: payroll_dates_bool_exp
  payroll_dates_aggregate: payroll_dates_aggregate_bool_exp
  payroll_system: String_comparison_exp
  primary_consultant_user_id: uuid_comparison_exp
  processing_days_before_eft: Int_comparison_exp
  processing_time: Int_comparison_exp
  status: payroll_status_comparison_exp
  updated_at: timestamptz_comparison_exp
  userByBackupConsultantUserId: users_bool_exp
  userByManagerUserId: users_bool_exp
  userByPrimaryConsultantUserId: users_bool_exp
}

"""
unique or primary key constraints on table "payrolls"
"""
enum payrolls_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  payrolls_pkey
}

"""
input type for incrementing numeric columns in table "payrolls"
"""
input payrolls_inc_input {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: Int

  """Number of employees in this payroll"""
  employee_count: Int

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Int

  """Number of hours required to process this payroll"""
  processing_time: Int
}

"""
input type for inserting data into table "payrolls"
"""
input payrolls_insert_input {
  """Backup consultant for this payroll"""
  backup_consultant_user_id: uuid
  client: clients_obj_rel_insert_input

  """Reference to the client this payroll belongs to"""
  client_id: uuid

  """Timestamp when the payroll was created"""
  created_at: timestamptz

  """Reference to the payroll cycle"""
  cycle_id: uuid

  """Reference to the payroll date type"""
  date_type_id: uuid

  """Specific value for date calculation (e.g., day of month)"""
  date_value: Int

  """Number of employees in this payroll"""
  employee_count: Int

  """The date when the payroll went live in the system"""
  go_live_date: date

  """Unique identifier for the payroll"""
  id: uuid

  """Manager overseeing this payroll"""
  manager_user_id: uuid

  """Name of the payroll"""
  name: String
  payroll_cycle: payroll_cycles_obj_rel_insert_input
  payroll_date_type: payroll_date_types_obj_rel_insert_input
  payroll_dates: payroll_dates_arr_rel_insert_input

  """External payroll system used for this client"""
  payroll_system: String

  """Primary consultant responsible for this payroll"""
  primary_consultant_user_id: uuid

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Int

  """Number of hours required to process this payroll"""
  processing_time: Int

  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status

  """Timestamp when the payroll was last updated"""
  updated_at: timestamptz
  userByBackupConsultantUserId: users_obj_rel_insert_input
  userByManagerUserId: users_obj_rel_insert_input
  userByPrimaryConsultantUserId: users_obj_rel_insert_input
}

"""aggregate max on columns"""
type payrolls_max_fields {
  """Backup consultant for this payroll"""
  backup_consultant_user_id: uuid

  """Reference to the client this payroll belongs to"""
  client_id: uuid

  """Timestamp when the payroll was created"""
  created_at: timestamptz

  """Reference to the payroll cycle"""
  cycle_id: uuid

  """Reference to the payroll date type"""
  date_type_id: uuid

  """Specific value for date calculation (e.g., day of month)"""
  date_value: Int

  """Number of employees in this payroll"""
  employee_count: Int

  """The date when the payroll went live in the system"""
  go_live_date: date

  """Unique identifier for the payroll"""
  id: uuid

  """Manager overseeing this payroll"""
  manager_user_id: uuid

  """Name of the payroll"""
  name: String

  """External payroll system used for this client"""
  payroll_system: String

  """Primary consultant responsible for this payroll"""
  primary_consultant_user_id: uuid

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Int

  """Number of hours required to process this payroll"""
  processing_time: Int

  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status

  """Timestamp when the payroll was last updated"""
  updated_at: timestamptz
}

"""
order by max() on columns of table "payrolls"
"""
input payrolls_max_order_by {
  """Backup consultant for this payroll"""
  backup_consultant_user_id: order_by

  """Reference to the client this payroll belongs to"""
  client_id: order_by

  """Timestamp when the payroll was created"""
  created_at: order_by

  """Reference to the payroll cycle"""
  cycle_id: order_by

  """Reference to the payroll date type"""
  date_type_id: order_by

  """Specific value for date calculation (e.g., day of month)"""
  date_value: order_by

  """Number of employees in this payroll"""
  employee_count: order_by

  """The date when the payroll went live in the system"""
  go_live_date: order_by

  """Unique identifier for the payroll"""
  id: order_by

  """Manager overseeing this payroll"""
  manager_user_id: order_by

  """Name of the payroll"""
  name: order_by

  """External payroll system used for this client"""
  payroll_system: order_by

  """Primary consultant responsible for this payroll"""
  primary_consultant_user_id: order_by

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: order_by

  """Number of hours required to process this payroll"""
  processing_time: order_by

  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: order_by

  """Timestamp when the payroll was last updated"""
  updated_at: order_by
}

"""aggregate min on columns"""
type payrolls_min_fields {
  """Backup consultant for this payroll"""
  backup_consultant_user_id: uuid

  """Reference to the client this payroll belongs to"""
  client_id: uuid

  """Timestamp when the payroll was created"""
  created_at: timestamptz

  """Reference to the payroll cycle"""
  cycle_id: uuid

  """Reference to the payroll date type"""
  date_type_id: uuid

  """Specific value for date calculation (e.g., day of month)"""
  date_value: Int

  """Number of employees in this payroll"""
  employee_count: Int

  """The date when the payroll went live in the system"""
  go_live_date: date

  """Unique identifier for the payroll"""
  id: uuid

  """Manager overseeing this payroll"""
  manager_user_id: uuid

  """Name of the payroll"""
  name: String

  """External payroll system used for this client"""
  payroll_system: String

  """Primary consultant responsible for this payroll"""
  primary_consultant_user_id: uuid

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Int

  """Number of hours required to process this payroll"""
  processing_time: Int

  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status

  """Timestamp when the payroll was last updated"""
  updated_at: timestamptz
}

"""
order by min() on columns of table "payrolls"
"""
input payrolls_min_order_by {
  """Backup consultant for this payroll"""
  backup_consultant_user_id: order_by

  """Reference to the client this payroll belongs to"""
  client_id: order_by

  """Timestamp when the payroll was created"""
  created_at: order_by

  """Reference to the payroll cycle"""
  cycle_id: order_by

  """Reference to the payroll date type"""
  date_type_id: order_by

  """Specific value for date calculation (e.g., day of month)"""
  date_value: order_by

  """Number of employees in this payroll"""
  employee_count: order_by

  """The date when the payroll went live in the system"""
  go_live_date: order_by

  """Unique identifier for the payroll"""
  id: order_by

  """Manager overseeing this payroll"""
  manager_user_id: order_by

  """Name of the payroll"""
  name: order_by

  """External payroll system used for this client"""
  payroll_system: order_by

  """Primary consultant responsible for this payroll"""
  primary_consultant_user_id: order_by

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: order_by

  """Number of hours required to process this payroll"""
  processing_time: order_by

  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: order_by

  """Timestamp when the payroll was last updated"""
  updated_at: order_by
}

"""
response of any mutation on the table "payrolls"
"""
type payrolls_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payrolls!]!
}

"""
input type for inserting object relation for remote table "payrolls"
"""
input payrolls_obj_rel_insert_input {
  data: payrolls_insert_input!

  """upsert condition"""
  on_conflict: payrolls_on_conflict
}

"""
on_conflict condition type for table "payrolls"
"""
input payrolls_on_conflict {
  constraint: payrolls_constraint!
  update_columns: [payrolls_update_column!]! = []
  where: payrolls_bool_exp
}

"""Ordering options when selecting data from "payrolls"."""
input payrolls_order_by {
  backup_consultant_user_id: order_by
  client: clients_order_by
  client_id: order_by
  created_at: order_by
  cycle_id: order_by
  date_type_id: order_by
  date_value: order_by
  employee_count: order_by
  go_live_date: order_by
  id: order_by
  manager_user_id: order_by
  name: order_by
  payroll_cycle: payroll_cycles_order_by
  payroll_date_type: payroll_date_types_order_by
  payroll_dates_aggregate: payroll_dates_aggregate_order_by
  payroll_system: order_by
  primary_consultant_user_id: order_by
  processing_days_before_eft: order_by
  processing_time: order_by
  status: order_by
  updated_at: order_by
  userByBackupConsultantUserId: users_order_by
  userByManagerUserId: users_order_by
  userByPrimaryConsultantUserId: users_order_by
}

"""primary key columns input for table: payrolls"""
input payrolls_pk_columns_input {
  """Unique identifier for the payroll"""
  id: uuid!
}

"""
select columns of table "payrolls"
"""
enum payrolls_select_column {
  """column name"""
  backup_consultant_user_id

  """column name"""
  client_id

  """column name"""
  created_at

  """column name"""
  cycle_id

  """column name"""
  date_type_id

  """column name"""
  date_value

  """column name"""
  employee_count

  """column name"""
  go_live_date

  """column name"""
  id

  """column name"""
  manager_user_id

  """column name"""
  name

  """column name"""
  payroll_system

  """column name"""
  primary_consultant_user_id

  """column name"""
  processing_days_before_eft

  """column name"""
  processing_time

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "payrolls"
"""
input payrolls_set_input {
  """Backup consultant for this payroll"""
  backup_consultant_user_id: uuid

  """Reference to the client this payroll belongs to"""
  client_id: uuid

  """Timestamp when the payroll was created"""
  created_at: timestamptz

  """Reference to the payroll cycle"""
  cycle_id: uuid

  """Reference to the payroll date type"""
  date_type_id: uuid

  """Specific value for date calculation (e.g., day of month)"""
  date_value: Int

  """Number of employees in this payroll"""
  employee_count: Int

  """The date when the payroll went live in the system"""
  go_live_date: date

  """Unique identifier for the payroll"""
  id: uuid

  """Manager overseeing this payroll"""
  manager_user_id: uuid

  """Name of the payroll"""
  name: String

  """External payroll system used for this client"""
  payroll_system: String

  """Primary consultant responsible for this payroll"""
  primary_consultant_user_id: uuid

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Int

  """Number of hours required to process this payroll"""
  processing_time: Int

  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status

  """Timestamp when the payroll was last updated"""
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type payrolls_stddev_fields {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: Float

  """Number of employees in this payroll"""
  employee_count: Float

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Float

  """Number of hours required to process this payroll"""
  processing_time: Float
}

"""
order by stddev() on columns of table "payrolls"
"""
input payrolls_stddev_order_by {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: order_by

  """Number of employees in this payroll"""
  employee_count: order_by

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: order_by

  """Number of hours required to process this payroll"""
  processing_time: order_by
}

"""aggregate stddev_pop on columns"""
type payrolls_stddev_pop_fields {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: Float

  """Number of employees in this payroll"""
  employee_count: Float

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Float

  """Number of hours required to process this payroll"""
  processing_time: Float
}

"""
order by stddev_pop() on columns of table "payrolls"
"""
input payrolls_stddev_pop_order_by {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: order_by

  """Number of employees in this payroll"""
  employee_count: order_by

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: order_by

  """Number of hours required to process this payroll"""
  processing_time: order_by
}

"""aggregate stddev_samp on columns"""
type payrolls_stddev_samp_fields {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: Float

  """Number of employees in this payroll"""
  employee_count: Float

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Float

  """Number of hours required to process this payroll"""
  processing_time: Float
}

"""
order by stddev_samp() on columns of table "payrolls"
"""
input payrolls_stddev_samp_order_by {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: order_by

  """Number of employees in this payroll"""
  employee_count: order_by

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: order_by

  """Number of hours required to process this payroll"""
  processing_time: order_by
}

"""
Streaming cursor of the table "payrolls"
"""
input payrolls_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payrolls_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payrolls_stream_cursor_value_input {
  """Backup consultant for this payroll"""
  backup_consultant_user_id: uuid

  """Reference to the client this payroll belongs to"""
  client_id: uuid

  """Timestamp when the payroll was created"""
  created_at: timestamptz

  """Reference to the payroll cycle"""
  cycle_id: uuid

  """Reference to the payroll date type"""
  date_type_id: uuid

  """Specific value for date calculation (e.g., day of month)"""
  date_value: Int

  """Number of employees in this payroll"""
  employee_count: Int

  """The date when the payroll went live in the system"""
  go_live_date: date

  """Unique identifier for the payroll"""
  id: uuid

  """Manager overseeing this payroll"""
  manager_user_id: uuid

  """Name of the payroll"""
  name: String

  """External payroll system used for this client"""
  payroll_system: String

  """Primary consultant responsible for this payroll"""
  primary_consultant_user_id: uuid

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Int

  """Number of hours required to process this payroll"""
  processing_time: Int

  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status

  """Timestamp when the payroll was last updated"""
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type payrolls_sum_fields {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: Int

  """Number of employees in this payroll"""
  employee_count: Int

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Int

  """Number of hours required to process this payroll"""
  processing_time: Int
}

"""
order by sum() on columns of table "payrolls"
"""
input payrolls_sum_order_by {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: order_by

  """Number of employees in this payroll"""
  employee_count: order_by

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: order_by

  """Number of hours required to process this payroll"""
  processing_time: order_by
}

"""
update columns of table "payrolls"
"""
enum payrolls_update_column {
  """column name"""
  backup_consultant_user_id

  """column name"""
  client_id

  """column name"""
  created_at

  """column name"""
  cycle_id

  """column name"""
  date_type_id

  """column name"""
  date_value

  """column name"""
  employee_count

  """column name"""
  go_live_date

  """column name"""
  id

  """column name"""
  manager_user_id

  """column name"""
  name

  """column name"""
  payroll_system

  """column name"""
  primary_consultant_user_id

  """column name"""
  processing_days_before_eft

  """column name"""
  processing_time

  """column name"""
  status

  """column name"""
  updated_at
}

input payrolls_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: payrolls_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: payrolls_set_input

  """filter the rows which have to be updated"""
  where: payrolls_bool_exp!
}

"""aggregate var_pop on columns"""
type payrolls_var_pop_fields {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: Float

  """Number of employees in this payroll"""
  employee_count: Float

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Float

  """Number of hours required to process this payroll"""
  processing_time: Float
}

"""
order by var_pop() on columns of table "payrolls"
"""
input payrolls_var_pop_order_by {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: order_by

  """Number of employees in this payroll"""
  employee_count: order_by

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: order_by

  """Number of hours required to process this payroll"""
  processing_time: order_by
}

"""aggregate var_samp on columns"""
type payrolls_var_samp_fields {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: Float

  """Number of employees in this payroll"""
  employee_count: Float

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Float

  """Number of hours required to process this payroll"""
  processing_time: Float
}

"""
order by var_samp() on columns of table "payrolls"
"""
input payrolls_var_samp_order_by {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: order_by

  """Number of employees in this payroll"""
  employee_count: order_by

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: order_by

  """Number of hours required to process this payroll"""
  processing_time: order_by
}

"""aggregate variance on columns"""
type payrolls_variance_fields {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: Float

  """Number of employees in this payroll"""
  employee_count: Float

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Float

  """Number of hours required to process this payroll"""
  processing_time: Float
}

"""
order by variance() on columns of table "payrolls"
"""
input payrolls_variance_order_by {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: order_by

  """Number of employees in this payroll"""
  employee_count: order_by

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: order_by

  """Number of hours required to process this payroll"""
  processing_time: order_by
}

"""
columns and relationships of "permission_audit_log"
"""
type permission_audit_log {
  """Specific action taken on the resource"""
  action: String!

  """Timestamp when the audit log entry was created"""
  created_at: timestamptz

  """Unique identifier for the audit log entry"""
  id: uuid!

  """New state after the change"""
  new_value(
    """JSON select path"""
    path: String
  ): jsonb

  """Type of operation performed (create, read, update, delete)"""
  operation: String!

  """An object relationship"""
  performed_by_user: users

  """Previous state before the change"""
  previous_value(
    """JSON select path"""
    path: String
  ): jsonb

  """Reason provided for the permission change"""
  reason: String

  """Resource that was accessed or modified"""
  resource: String!

  """Role affected by the permission change"""
  target_role: user_role

  """An object relationship"""
  target_user: users

  """User affected by the permission change"""
  target_user_id: uuid

  """User who performed the action"""
  user_id: uuid
}

"""
aggregated selection of "permission_audit_log"
"""
type permission_audit_log_aggregate {
  aggregate: permission_audit_log_aggregate_fields
  nodes: [permission_audit_log!]!
}

input permission_audit_log_aggregate_bool_exp {
  count: permission_audit_log_aggregate_bool_exp_count
}

input permission_audit_log_aggregate_bool_exp_count {
  arguments: [permission_audit_log_select_column!]
  distinct: Boolean
  filter: permission_audit_log_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "permission_audit_log"
"""
type permission_audit_log_aggregate_fields {
  count(columns: [permission_audit_log_select_column!], distinct: Boolean): Int!
  max: permission_audit_log_max_fields
  min: permission_audit_log_min_fields
}

"""
order by aggregate values of table "permission_audit_log"
"""
input permission_audit_log_aggregate_order_by {
  count: order_by
  max: permission_audit_log_max_order_by
  min: permission_audit_log_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input permission_audit_log_append_input {
  """New state after the change"""
  new_value: jsonb

  """Previous state before the change"""
  previous_value: jsonb
}

"""
input type for inserting array relation for remote table "permission_audit_log"
"""
input permission_audit_log_arr_rel_insert_input {
  data: [permission_audit_log_insert_input!]!

  """upsert condition"""
  on_conflict: permission_audit_log_on_conflict
}

"""
Boolean expression to filter rows from the table "permission_audit_log". All fields are combined with a logical 'AND'.
"""
input permission_audit_log_bool_exp {
  _and: [permission_audit_log_bool_exp!]
  _not: permission_audit_log_bool_exp
  _or: [permission_audit_log_bool_exp!]
  action: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  new_value: jsonb_comparison_exp
  operation: String_comparison_exp
  performed_by_user: users_bool_exp
  previous_value: jsonb_comparison_exp
  reason: String_comparison_exp
  resource: String_comparison_exp
  target_role: user_role_comparison_exp
  target_user: users_bool_exp
  target_user_id: uuid_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "permission_audit_log"
"""
enum permission_audit_log_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  permission_audit_log_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input permission_audit_log_delete_at_path_input {
  """New state after the change"""
  new_value: [String!]

  """Previous state before the change"""
  previous_value: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input permission_audit_log_delete_elem_input {
  """New state after the change"""
  new_value: Int

  """Previous state before the change"""
  previous_value: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input permission_audit_log_delete_key_input {
  """New state after the change"""
  new_value: String

  """Previous state before the change"""
  previous_value: String
}

"""
input type for inserting data into table "permission_audit_log"
"""
input permission_audit_log_insert_input {
  """Specific action taken on the resource"""
  action: String

  """Timestamp when the audit log entry was created"""
  created_at: timestamptz

  """Unique identifier for the audit log entry"""
  id: uuid

  """New state after the change"""
  new_value: jsonb

  """Type of operation performed (create, read, update, delete)"""
  operation: String
  performed_by_user: users_obj_rel_insert_input

  """Previous state before the change"""
  previous_value: jsonb

  """Reason provided for the permission change"""
  reason: String

  """Resource that was accessed or modified"""
  resource: String

  """Role affected by the permission change"""
  target_role: user_role
  target_user: users_obj_rel_insert_input

  """User affected by the permission change"""
  target_user_id: uuid

  """User who performed the action"""
  user_id: uuid
}

"""aggregate max on columns"""
type permission_audit_log_max_fields {
  """Specific action taken on the resource"""
  action: String

  """Timestamp when the audit log entry was created"""
  created_at: timestamptz

  """Unique identifier for the audit log entry"""
  id: uuid

  """Type of operation performed (create, read, update, delete)"""
  operation: String

  """Reason provided for the permission change"""
  reason: String

  """Resource that was accessed or modified"""
  resource: String

  """Role affected by the permission change"""
  target_role: user_role

  """User affected by the permission change"""
  target_user_id: uuid

  """User who performed the action"""
  user_id: uuid
}

"""
order by max() on columns of table "permission_audit_log"
"""
input permission_audit_log_max_order_by {
  """Specific action taken on the resource"""
  action: order_by

  """Timestamp when the audit log entry was created"""
  created_at: order_by

  """Unique identifier for the audit log entry"""
  id: order_by

  """Type of operation performed (create, read, update, delete)"""
  operation: order_by

  """Reason provided for the permission change"""
  reason: order_by

  """Resource that was accessed or modified"""
  resource: order_by

  """Role affected by the permission change"""
  target_role: order_by

  """User affected by the permission change"""
  target_user_id: order_by

  """User who performed the action"""
  user_id: order_by
}

"""aggregate min on columns"""
type permission_audit_log_min_fields {
  """Specific action taken on the resource"""
  action: String

  """Timestamp when the audit log entry was created"""
  created_at: timestamptz

  """Unique identifier for the audit log entry"""
  id: uuid

  """Type of operation performed (create, read, update, delete)"""
  operation: String

  """Reason provided for the permission change"""
  reason: String

  """Resource that was accessed or modified"""
  resource: String

  """Role affected by the permission change"""
  target_role: user_role

  """User affected by the permission change"""
  target_user_id: uuid

  """User who performed the action"""
  user_id: uuid
}

"""
order by min() on columns of table "permission_audit_log"
"""
input permission_audit_log_min_order_by {
  """Specific action taken on the resource"""
  action: order_by

  """Timestamp when the audit log entry was created"""
  created_at: order_by

  """Unique identifier for the audit log entry"""
  id: order_by

  """Type of operation performed (create, read, update, delete)"""
  operation: order_by

  """Reason provided for the permission change"""
  reason: order_by

  """Resource that was accessed or modified"""
  resource: order_by

  """Role affected by the permission change"""
  target_role: order_by

  """User affected by the permission change"""
  target_user_id: order_by

  """User who performed the action"""
  user_id: order_by
}

"""
response of any mutation on the table "permission_audit_log"
"""
type permission_audit_log_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [permission_audit_log!]!
}

"""
on_conflict condition type for table "permission_audit_log"
"""
input permission_audit_log_on_conflict {
  constraint: permission_audit_log_constraint!
  update_columns: [permission_audit_log_update_column!]! = []
  where: permission_audit_log_bool_exp
}

"""Ordering options when selecting data from "permission_audit_log"."""
input permission_audit_log_order_by {
  action: order_by
  created_at: order_by
  id: order_by
  new_value: order_by
  operation: order_by
  performed_by_user: users_order_by
  previous_value: order_by
  reason: order_by
  resource: order_by
  target_role: order_by
  target_user: users_order_by
  target_user_id: order_by
  user_id: order_by
}

"""primary key columns input for table: permission_audit_log"""
input permission_audit_log_pk_columns_input {
  """Unique identifier for the audit log entry"""
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input permission_audit_log_prepend_input {
  """New state after the change"""
  new_value: jsonb

  """Previous state before the change"""
  previous_value: jsonb
}

"""
select columns of table "permission_audit_log"
"""
enum permission_audit_log_select_column {
  """column name"""
  action

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  new_value

  """column name"""
  operation

  """column name"""
  previous_value

  """column name"""
  reason

  """column name"""
  resource

  """column name"""
  target_role

  """column name"""
  target_user_id

  """column name"""
  user_id
}

"""
input type for updating data in table "permission_audit_log"
"""
input permission_audit_log_set_input {
  """Specific action taken on the resource"""
  action: String

  """Timestamp when the audit log entry was created"""
  created_at: timestamptz

  """Unique identifier for the audit log entry"""
  id: uuid

  """New state after the change"""
  new_value: jsonb

  """Type of operation performed (create, read, update, delete)"""
  operation: String

  """Previous state before the change"""
  previous_value: jsonb

  """Reason provided for the permission change"""
  reason: String

  """Resource that was accessed or modified"""
  resource: String

  """Role affected by the permission change"""
  target_role: user_role

  """User affected by the permission change"""
  target_user_id: uuid

  """User who performed the action"""
  user_id: uuid
}

"""
Streaming cursor of the table "permission_audit_log"
"""
input permission_audit_log_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: permission_audit_log_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input permission_audit_log_stream_cursor_value_input {
  """Specific action taken on the resource"""
  action: String

  """Timestamp when the audit log entry was created"""
  created_at: timestamptz

  """Unique identifier for the audit log entry"""
  id: uuid

  """New state after the change"""
  new_value: jsonb

  """Type of operation performed (create, read, update, delete)"""
  operation: String

  """Previous state before the change"""
  previous_value: jsonb

  """Reason provided for the permission change"""
  reason: String

  """Resource that was accessed or modified"""
  resource: String

  """Role affected by the permission change"""
  target_role: user_role

  """User affected by the permission change"""
  target_user_id: uuid

  """User who performed the action"""
  user_id: uuid
}

"""
update columns of table "permission_audit_log"
"""
enum permission_audit_log_update_column {
  """column name"""
  action

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  new_value

  """column name"""
  operation

  """column name"""
  previous_value

  """column name"""
  reason

  """column name"""
  resource

  """column name"""
  target_role

  """column name"""
  target_user_id

  """column name"""
  user_id
}

input permission_audit_log_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: permission_audit_log_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: permission_audit_log_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: permission_audit_log_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: permission_audit_log_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: permission_audit_log_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: permission_audit_log_set_input

  """filter the rows which have to be updated"""
  where: permission_audit_log_bool_exp!
}

"""
columns and relationships of "permission_overrides"
"""
type permission_overrides {
  """JSON with additional conditions for the override"""
  conditions(
    """JSON select path"""
    path: String
  ): jsonb

  """Timestamp when the override was created"""
  created_at: timestamp

  """User who created this override"""
  created_by: uuid

  """An object relationship"""
  created_by_user: users

  """Timestamp when this override expires"""
  expires_at: timestamp

  """Whether the permission is granted (true) or denied (false)"""
  granted: Boolean!

  """Unique identifier for the permission override"""
  id: uuid!

  """Operation being permitted or restricted"""
  operation: String!

  """An object relationship"""
  override_user: users

  """Resource affected by this override"""
  resource: String!

  """Role this override applies to"""
  role: user_role

  """An object relationship"""
  user: users

  """User receiving the permission override"""
  user_id: uuid
}

"""
aggregated selection of "permission_overrides"
"""
type permission_overrides_aggregate {
  aggregate: permission_overrides_aggregate_fields
  nodes: [permission_overrides!]!
}

input permission_overrides_aggregate_bool_exp {
  bool_and: permission_overrides_aggregate_bool_exp_bool_and
  bool_or: permission_overrides_aggregate_bool_exp_bool_or
  count: permission_overrides_aggregate_bool_exp_count
}

input permission_overrides_aggregate_bool_exp_bool_and {
  arguments: permission_overrides_select_column_permission_overrides_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: permission_overrides_bool_exp
  predicate: Boolean_comparison_exp!
}

input permission_overrides_aggregate_bool_exp_bool_or {
  arguments: permission_overrides_select_column_permission_overrides_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: permission_overrides_bool_exp
  predicate: Boolean_comparison_exp!
}

input permission_overrides_aggregate_bool_exp_count {
  arguments: [permission_overrides_select_column!]
  distinct: Boolean
  filter: permission_overrides_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "permission_overrides"
"""
type permission_overrides_aggregate_fields {
  count(columns: [permission_overrides_select_column!], distinct: Boolean): Int!
  max: permission_overrides_max_fields
  min: permission_overrides_min_fields
}

"""
order by aggregate values of table "permission_overrides"
"""
input permission_overrides_aggregate_order_by {
  count: order_by
  max: permission_overrides_max_order_by
  min: permission_overrides_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input permission_overrides_append_input {
  """JSON with additional conditions for the override"""
  conditions: jsonb
}

"""
input type for inserting array relation for remote table "permission_overrides"
"""
input permission_overrides_arr_rel_insert_input {
  data: [permission_overrides_insert_input!]!

  """upsert condition"""
  on_conflict: permission_overrides_on_conflict
}

"""
Boolean expression to filter rows from the table "permission_overrides". All fields are combined with a logical 'AND'.
"""
input permission_overrides_bool_exp {
  _and: [permission_overrides_bool_exp!]
  _not: permission_overrides_bool_exp
  _or: [permission_overrides_bool_exp!]
  conditions: jsonb_comparison_exp
  created_at: timestamp_comparison_exp
  created_by: uuid_comparison_exp
  created_by_user: users_bool_exp
  expires_at: timestamp_comparison_exp
  granted: Boolean_comparison_exp
  id: uuid_comparison_exp
  operation: String_comparison_exp
  override_user: users_bool_exp
  resource: String_comparison_exp
  role: user_role_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "permission_overrides"
"""
enum permission_overrides_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  permission_overrides_pkey

  """
  unique or primary key constraint on columns "operation", "resource", "role"
  """
  unique_role_resource_operation

  """
  unique or primary key constraint on columns "operation", "user_id", "resource"
  """
  unique_user_resource_operation
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input permission_overrides_delete_at_path_input {
  """JSON with additional conditions for the override"""
  conditions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input permission_overrides_delete_elem_input {
  """JSON with additional conditions for the override"""
  conditions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input permission_overrides_delete_key_input {
  """JSON with additional conditions for the override"""
  conditions: String
}

"""
input type for inserting data into table "permission_overrides"
"""
input permission_overrides_insert_input {
  """JSON with additional conditions for the override"""
  conditions: jsonb

  """Timestamp when the override was created"""
  created_at: timestamp

  """User who created this override"""
  created_by: uuid
  created_by_user: users_obj_rel_insert_input

  """Timestamp when this override expires"""
  expires_at: timestamp

  """Whether the permission is granted (true) or denied (false)"""
  granted: Boolean

  """Unique identifier for the permission override"""
  id: uuid

  """Operation being permitted or restricted"""
  operation: String
  override_user: users_obj_rel_insert_input

  """Resource affected by this override"""
  resource: String

  """Role this override applies to"""
  role: user_role
  user: users_obj_rel_insert_input

  """User receiving the permission override"""
  user_id: uuid
}

"""aggregate max on columns"""
type permission_overrides_max_fields {
  """Timestamp when the override was created"""
  created_at: timestamp

  """User who created this override"""
  created_by: uuid

  """Timestamp when this override expires"""
  expires_at: timestamp

  """Unique identifier for the permission override"""
  id: uuid

  """Operation being permitted or restricted"""
  operation: String

  """Resource affected by this override"""
  resource: String

  """Role this override applies to"""
  role: user_role

  """User receiving the permission override"""
  user_id: uuid
}

"""
order by max() on columns of table "permission_overrides"
"""
input permission_overrides_max_order_by {
  """Timestamp when the override was created"""
  created_at: order_by

  """User who created this override"""
  created_by: order_by

  """Timestamp when this override expires"""
  expires_at: order_by

  """Unique identifier for the permission override"""
  id: order_by

  """Operation being permitted or restricted"""
  operation: order_by

  """Resource affected by this override"""
  resource: order_by

  """Role this override applies to"""
  role: order_by

  """User receiving the permission override"""
  user_id: order_by
}

"""aggregate min on columns"""
type permission_overrides_min_fields {
  """Timestamp when the override was created"""
  created_at: timestamp

  """User who created this override"""
  created_by: uuid

  """Timestamp when this override expires"""
  expires_at: timestamp

  """Unique identifier for the permission override"""
  id: uuid

  """Operation being permitted or restricted"""
  operation: String

  """Resource affected by this override"""
  resource: String

  """Role this override applies to"""
  role: user_role

  """User receiving the permission override"""
  user_id: uuid
}

"""
order by min() on columns of table "permission_overrides"
"""
input permission_overrides_min_order_by {
  """Timestamp when the override was created"""
  created_at: order_by

  """User who created this override"""
  created_by: order_by

  """Timestamp when this override expires"""
  expires_at: order_by

  """Unique identifier for the permission override"""
  id: order_by

  """Operation being permitted or restricted"""
  operation: order_by

  """Resource affected by this override"""
  resource: order_by

  """Role this override applies to"""
  role: order_by

  """User receiving the permission override"""
  user_id: order_by
}

"""
response of any mutation on the table "permission_overrides"
"""
type permission_overrides_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [permission_overrides!]!
}

"""
on_conflict condition type for table "permission_overrides"
"""
input permission_overrides_on_conflict {
  constraint: permission_overrides_constraint!
  update_columns: [permission_overrides_update_column!]! = []
  where: permission_overrides_bool_exp
}

"""Ordering options when selecting data from "permission_overrides"."""
input permission_overrides_order_by {
  conditions: order_by
  created_at: order_by
  created_by: order_by
  created_by_user: users_order_by
  expires_at: order_by
  granted: order_by
  id: order_by
  operation: order_by
  override_user: users_order_by
  resource: order_by
  role: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: permission_overrides"""
input permission_overrides_pk_columns_input {
  """Unique identifier for the permission override"""
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input permission_overrides_prepend_input {
  """JSON with additional conditions for the override"""
  conditions: jsonb
}

"""
select columns of table "permission_overrides"
"""
enum permission_overrides_select_column {
  """column name"""
  conditions

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  expires_at

  """column name"""
  granted

  """column name"""
  id

  """column name"""
  operation

  """column name"""
  resource

  """column name"""
  role

  """column name"""
  user_id
}

"""
select "permission_overrides_aggregate_bool_exp_bool_and_arguments_columns" columns of table "permission_overrides"
"""
enum permission_overrides_select_column_permission_overrides_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  granted
}

"""
select "permission_overrides_aggregate_bool_exp_bool_or_arguments_columns" columns of table "permission_overrides"
"""
enum permission_overrides_select_column_permission_overrides_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  granted
}

"""
input type for updating data in table "permission_overrides"
"""
input permission_overrides_set_input {
  """JSON with additional conditions for the override"""
  conditions: jsonb

  """Timestamp when the override was created"""
  created_at: timestamp

  """User who created this override"""
  created_by: uuid

  """Timestamp when this override expires"""
  expires_at: timestamp

  """Whether the permission is granted (true) or denied (false)"""
  granted: Boolean

  """Unique identifier for the permission override"""
  id: uuid

  """Operation being permitted or restricted"""
  operation: String

  """Resource affected by this override"""
  resource: String

  """Role this override applies to"""
  role: user_role

  """User receiving the permission override"""
  user_id: uuid
}

"""
Streaming cursor of the table "permission_overrides"
"""
input permission_overrides_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: permission_overrides_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input permission_overrides_stream_cursor_value_input {
  """JSON with additional conditions for the override"""
  conditions: jsonb

  """Timestamp when the override was created"""
  created_at: timestamp

  """User who created this override"""
  created_by: uuid

  """Timestamp when this override expires"""
  expires_at: timestamp

  """Whether the permission is granted (true) or denied (false)"""
  granted: Boolean

  """Unique identifier for the permission override"""
  id: uuid

  """Operation being permitted or restricted"""
  operation: String

  """Resource affected by this override"""
  resource: String

  """Role this override applies to"""
  role: user_role

  """User receiving the permission override"""
  user_id: uuid
}

"""
update columns of table "permission_overrides"
"""
enum permission_overrides_update_column {
  """column name"""
  conditions

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  expires_at

  """column name"""
  granted

  """column name"""
  id

  """column name"""
  operation

  """column name"""
  resource

  """column name"""
  role

  """column name"""
  user_id
}

input permission_overrides_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: permission_overrides_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: permission_overrides_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: permission_overrides_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: permission_overrides_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: permission_overrides_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: permission_overrides_set_input

  """filter the rows which have to be updated"""
  where: permission_overrides_bool_exp!
}

type query_root {
  """query _Entity union"""
  _entities(representations: [_Any!]!): _Entity
  _service: _Service!

  """An array relationship"""
  adjustment_rules(
    """distinct select on columns"""
    distinct_on: [adjustment_rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [adjustment_rules_order_by!]

    """filter the rows returned"""
    where: adjustment_rules_bool_exp
  ): [adjustment_rules!]!

  """An aggregate relationship"""
  adjustment_rules_aggregate(
    """distinct select on columns"""
    distinct_on: [adjustment_rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [adjustment_rules_order_by!]

    """filter the rows returned"""
    where: adjustment_rules_bool_exp
  ): adjustment_rules_aggregate!

  """
  fetch data from the table: "adjustment_rules" using primary key columns
  """
  adjustment_rules_by_pk(
    """Unique identifier for the adjustment rule"""
    id: uuid!
  ): adjustment_rules

  """
  fetch data from the table: "app_settings"
  """
  app_settings(
    """distinct select on columns"""
    distinct_on: [app_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_settings_order_by!]

    """filter the rows returned"""
    where: app_settings_bool_exp
  ): [app_settings!]!

  """
  fetch aggregated fields from the table: "app_settings"
  """
  app_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [app_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_settings_order_by!]

    """filter the rows returned"""
    where: app_settings_bool_exp
  ): app_settings_aggregate!

  """fetch data from the table: "app_settings" using primary key columns"""
  app_settings_by_pk(
    """Unique identifier for application setting"""
    id: String!
  ): app_settings

  """An array relationship"""
  client_external_systems(
    """distinct select on columns"""
    distinct_on: [client_external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_external_systems_order_by!]

    """filter the rows returned"""
    where: client_external_systems_bool_exp
  ): [client_external_systems!]!

  """An aggregate relationship"""
  client_external_systems_aggregate(
    """distinct select on columns"""
    distinct_on: [client_external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_external_systems_order_by!]

    """filter the rows returned"""
    where: client_external_systems_bool_exp
  ): client_external_systems_aggregate!

  """
  fetch data from the table: "client_external_systems" using primary key columns
  """
  client_external_systems_by_pk(
    """Unique identifier for the client-system mapping"""
    id: uuid!
  ): client_external_systems

  """
  fetch data from the table: "clients"
  """
  clients(
    """distinct select on columns"""
    distinct_on: [clients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clients_order_by!]

    """filter the rows returned"""
    where: clients_bool_exp
  ): [clients!]!

  """
  fetch aggregated fields from the table: "clients"
  """
  clients_aggregate(
    """distinct select on columns"""
    distinct_on: [clients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clients_order_by!]

    """filter the rows returned"""
    where: clients_bool_exp
  ): clients_aggregate!

  """fetch data from the table: "clients" using primary key columns"""
  clients_by_pk(
    """Unique identifier for the client"""
    id: uuid!
  ): clients

  """
  fetch data from the table: "external_systems"
  """
  external_systems(
    """distinct select on columns"""
    distinct_on: [external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_systems_order_by!]

    """filter the rows returned"""
    where: external_systems_bool_exp
  ): [external_systems!]!

  """
  fetch aggregated fields from the table: "external_systems"
  """
  external_systems_aggregate(
    """distinct select on columns"""
    distinct_on: [external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_systems_order_by!]

    """filter the rows returned"""
    where: external_systems_bool_exp
  ): external_systems_aggregate!

  """
  fetch data from the table: "external_systems" using primary key columns
  """
  external_systems_by_pk(
    """Unique identifier for the external system"""
    id: uuid!
  ): external_systems

  """
  fetch data from the table: "feature_flags"
  """
  feature_flags(
    """distinct select on columns"""
    distinct_on: [feature_flags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_flags_order_by!]

    """filter the rows returned"""
    where: feature_flags_bool_exp
  ): [feature_flags!]!

  """
  fetch aggregated fields from the table: "feature_flags"
  """
  feature_flags_aggregate(
    """distinct select on columns"""
    distinct_on: [feature_flags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_flags_order_by!]

    """filter the rows returned"""
    where: feature_flags_bool_exp
  ): feature_flags_aggregate!

  """fetch data from the table: "feature_flags" using primary key columns"""
  feature_flags_by_pk(
    """Unique identifier for the feature flag"""
    id: uuid!
  ): feature_flags

  """
  execute function "generate_payroll_dates" which returns "payroll_dates"
  """
  generate_payroll_dates(
    """
    input parameters for function "generate_payroll_dates"
    """
    args: generate_payroll_dates_args!

    """distinct select on columns"""
    distinct_on: [payroll_dates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_dates_order_by!]

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): [payroll_dates!]!

  """
  execute function "generate_payroll_dates" and query aggregates on result of table type "payroll_dates"
  """
  generate_payroll_dates_aggregate(
    """
    input parameters for function "generate_payroll_dates_aggregate"
    """
    args: generate_payroll_dates_args!

    """distinct select on columns"""
    distinct_on: [payroll_dates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_dates_order_by!]

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): payroll_dates_aggregate!

  """
  fetch data from the table: "holidays"
  """
  holidays(
    """distinct select on columns"""
    distinct_on: [holidays_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [holidays_order_by!]

    """filter the rows returned"""
    where: holidays_bool_exp
  ): [holidays!]!

  """
  fetch aggregated fields from the table: "holidays"
  """
  holidays_aggregate(
    """distinct select on columns"""
    distinct_on: [holidays_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [holidays_order_by!]

    """filter the rows returned"""
    where: holidays_bool_exp
  ): holidays_aggregate!

  """fetch data from the table: "holidays" using primary key columns"""
  holidays_by_pk(
    """Unique identifier for the holiday"""
    id: uuid!
  ): holidays

  """
  fetch data from the table: "leave"
  """
  leave(
    """distinct select on columns"""
    distinct_on: [leave_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_order_by!]

    """filter the rows returned"""
    where: leave_bool_exp
  ): [leave!]!

  """
  fetch aggregated fields from the table: "leave"
  """
  leave_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_order_by!]

    """filter the rows returned"""
    where: leave_bool_exp
  ): leave_aggregate!

  """fetch data from the table: "leave" using primary key columns"""
  leave_by_pk(
    """Unique identifier for the leave record"""
    id: uuid!
  ): leave

  """
  fetch data from the table: "neon_auth.users_sync"
  """
  neon_auth_users_sync(
    """distinct select on columns"""
    distinct_on: [neon_auth_users_sync_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neon_auth_users_sync_order_by!]

    """filter the rows returned"""
    where: neon_auth_users_sync_bool_exp
  ): [neon_auth_users_sync!]!

  """
  fetch aggregated fields from the table: "neon_auth.users_sync"
  """
  neon_auth_users_sync_aggregate(
    """distinct select on columns"""
    distinct_on: [neon_auth_users_sync_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neon_auth_users_sync_order_by!]

    """filter the rows returned"""
    where: neon_auth_users_sync_bool_exp
  ): neon_auth_users_sync_aggregate!

  """
  fetch data from the table: "neon_auth.users_sync" using primary key columns
  """
  neon_auth_users_sync_by_pk(
    """Unique identifier from the authentication provider"""
    id: String!
  ): neon_auth_users_sync

  """
  fetch data from the table: "notes"
  """
  notes(
    """distinct select on columns"""
    distinct_on: [notes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_order_by!]

    """filter the rows returned"""
    where: notes_bool_exp
  ): [notes!]!

  """
  fetch aggregated fields from the table: "notes"
  """
  notes_aggregate(
    """distinct select on columns"""
    distinct_on: [notes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_order_by!]

    """filter the rows returned"""
    where: notes_bool_exp
  ): notes_aggregate!

  """fetch data from the table: "notes" using primary key columns"""
  notes_by_pk(
    """Unique identifier for the note"""
    id: uuid!
  ): notes

  """
  fetch data from the table: "payroll_cycles"
  """
  payroll_cycles(
    """distinct select on columns"""
    distinct_on: [payroll_cycles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_cycles_order_by!]

    """filter the rows returned"""
    where: payroll_cycles_bool_exp
  ): [payroll_cycles!]!

  """
  fetch aggregated fields from the table: "payroll_cycles"
  """
  payroll_cycles_aggregate(
    """distinct select on columns"""
    distinct_on: [payroll_cycles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_cycles_order_by!]

    """filter the rows returned"""
    where: payroll_cycles_bool_exp
  ): payroll_cycles_aggregate!

  """fetch data from the table: "payroll_cycles" using primary key columns"""
  payroll_cycles_by_pk(
    """Unique identifier for the payroll cycle"""
    id: uuid!
  ): payroll_cycles

  """
  fetch data from the table: "payroll_date_types"
  """
  payroll_date_types(
    """distinct select on columns"""
    distinct_on: [payroll_date_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_date_types_order_by!]

    """filter the rows returned"""
    where: payroll_date_types_bool_exp
  ): [payroll_date_types!]!

  """
  fetch aggregated fields from the table: "payroll_date_types"
  """
  payroll_date_types_aggregate(
    """distinct select on columns"""
    distinct_on: [payroll_date_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_date_types_order_by!]

    """filter the rows returned"""
    where: payroll_date_types_bool_exp
  ): payroll_date_types_aggregate!

  """
  fetch data from the table: "payroll_date_types" using primary key columns
  """
  payroll_date_types_by_pk(
    """Unique identifier for the payroll date type"""
    id: uuid!
  ): payroll_date_types

  """An array relationship"""
  payroll_dates(
    """distinct select on columns"""
    distinct_on: [payroll_dates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_dates_order_by!]

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): [payroll_dates!]!

  """An aggregate relationship"""
  payroll_dates_aggregate(
    """distinct select on columns"""
    distinct_on: [payroll_dates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_dates_order_by!]

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): payroll_dates_aggregate!

  """fetch data from the table: "payroll_dates" using primary key columns"""
  payroll_dates_by_pk(
    """Unique identifier for the payroll date"""
    id: uuid!
  ): payroll_dates

  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """An aggregate relationship"""
  payrolls_aggregate(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): payrolls_aggregate!

  """fetch data from the table: "payrolls" using primary key columns"""
  payrolls_by_pk(
    """Unique identifier for the payroll"""
    id: uuid!
  ): payrolls

  """
  fetch data from the table: "permission_audit_log"
  """
  permission_audit_log(
    """distinct select on columns"""
    distinct_on: [permission_audit_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_audit_log_order_by!]

    """filter the rows returned"""
    where: permission_audit_log_bool_exp
  ): [permission_audit_log!]!

  """
  fetch aggregated fields from the table: "permission_audit_log"
  """
  permission_audit_log_aggregate(
    """distinct select on columns"""
    distinct_on: [permission_audit_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_audit_log_order_by!]

    """filter the rows returned"""
    where: permission_audit_log_bool_exp
  ): permission_audit_log_aggregate!

  """
  fetch data from the table: "permission_audit_log" using primary key columns
  """
  permission_audit_log_by_pk(
    """Unique identifier for the audit log entry"""
    id: uuid!
  ): permission_audit_log

  """
  fetch data from the table: "permission_overrides"
  """
  permission_overrides(
    """distinct select on columns"""
    distinct_on: [permission_overrides_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_overrides_order_by!]

    """filter the rows returned"""
    where: permission_overrides_bool_exp
  ): [permission_overrides!]!

  """
  fetch aggregated fields from the table: "permission_overrides"
  """
  permission_overrides_aggregate(
    """distinct select on columns"""
    distinct_on: [permission_overrides_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_overrides_order_by!]

    """filter the rows returned"""
    where: permission_overrides_bool_exp
  ): permission_overrides_aggregate!

  """
  fetch data from the table: "permission_overrides" using primary key columns
  """
  permission_overrides_by_pk(
    """Unique identifier for the permission override"""
    id: uuid!
  ): permission_overrides

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(
    """Unique identifier for the user"""
    id: uuid!
  ): users

  """
  fetch data from the table: "work_schedule"
  """
  work_schedule(
    """distinct select on columns"""
    distinct_on: [work_schedule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [work_schedule_order_by!]

    """filter the rows returned"""
    where: work_schedule_bool_exp
  ): [work_schedule!]!

  """
  fetch aggregated fields from the table: "work_schedule"
  """
  work_schedule_aggregate(
    """distinct select on columns"""
    distinct_on: [work_schedule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [work_schedule_order_by!]

    """filter the rows returned"""
    where: work_schedule_bool_exp
  ): work_schedule_aggregate!

  """fetch data from the table: "work_schedule" using primary key columns"""
  work_schedule_by_pk(
    """Unique identifier for the work schedule entry"""
    id: uuid!
  ): work_schedule
}

type subscription_root {
  """An array relationship"""
  adjustment_rules(
    """distinct select on columns"""
    distinct_on: [adjustment_rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [adjustment_rules_order_by!]

    """filter the rows returned"""
    where: adjustment_rules_bool_exp
  ): [adjustment_rules!]!

  """An aggregate relationship"""
  adjustment_rules_aggregate(
    """distinct select on columns"""
    distinct_on: [adjustment_rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [adjustment_rules_order_by!]

    """filter the rows returned"""
    where: adjustment_rules_bool_exp
  ): adjustment_rules_aggregate!

  """
  fetch data from the table: "adjustment_rules" using primary key columns
  """
  adjustment_rules_by_pk(
    """Unique identifier for the adjustment rule"""
    id: uuid!
  ): adjustment_rules

  """
  fetch data from the table in a streaming manner: "adjustment_rules"
  """
  adjustment_rules_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [adjustment_rules_stream_cursor_input]!

    """filter the rows returned"""
    where: adjustment_rules_bool_exp
  ): [adjustment_rules!]!

  """
  fetch data from the table: "app_settings"
  """
  app_settings(
    """distinct select on columns"""
    distinct_on: [app_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_settings_order_by!]

    """filter the rows returned"""
    where: app_settings_bool_exp
  ): [app_settings!]!

  """
  fetch aggregated fields from the table: "app_settings"
  """
  app_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [app_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_settings_order_by!]

    """filter the rows returned"""
    where: app_settings_bool_exp
  ): app_settings_aggregate!

  """fetch data from the table: "app_settings" using primary key columns"""
  app_settings_by_pk(
    """Unique identifier for application setting"""
    id: String!
  ): app_settings

  """
  fetch data from the table in a streaming manner: "app_settings"
  """
  app_settings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [app_settings_stream_cursor_input]!

    """filter the rows returned"""
    where: app_settings_bool_exp
  ): [app_settings!]!

  """An array relationship"""
  client_external_systems(
    """distinct select on columns"""
    distinct_on: [client_external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_external_systems_order_by!]

    """filter the rows returned"""
    where: client_external_systems_bool_exp
  ): [client_external_systems!]!

  """An aggregate relationship"""
  client_external_systems_aggregate(
    """distinct select on columns"""
    distinct_on: [client_external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_external_systems_order_by!]

    """filter the rows returned"""
    where: client_external_systems_bool_exp
  ): client_external_systems_aggregate!

  """
  fetch data from the table: "client_external_systems" using primary key columns
  """
  client_external_systems_by_pk(
    """Unique identifier for the client-system mapping"""
    id: uuid!
  ): client_external_systems

  """
  fetch data from the table in a streaming manner: "client_external_systems"
  """
  client_external_systems_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [client_external_systems_stream_cursor_input]!

    """filter the rows returned"""
    where: client_external_systems_bool_exp
  ): [client_external_systems!]!

  """
  fetch data from the table: "clients"
  """
  clients(
    """distinct select on columns"""
    distinct_on: [clients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clients_order_by!]

    """filter the rows returned"""
    where: clients_bool_exp
  ): [clients!]!

  """
  fetch aggregated fields from the table: "clients"
  """
  clients_aggregate(
    """distinct select on columns"""
    distinct_on: [clients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clients_order_by!]

    """filter the rows returned"""
    where: clients_bool_exp
  ): clients_aggregate!

  """fetch data from the table: "clients" using primary key columns"""
  clients_by_pk(
    """Unique identifier for the client"""
    id: uuid!
  ): clients

  """
  fetch data from the table in a streaming manner: "clients"
  """
  clients_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [clients_stream_cursor_input]!

    """filter the rows returned"""
    where: clients_bool_exp
  ): [clients!]!

  """
  fetch data from the table: "external_systems"
  """
  external_systems(
    """distinct select on columns"""
    distinct_on: [external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_systems_order_by!]

    """filter the rows returned"""
    where: external_systems_bool_exp
  ): [external_systems!]!

  """
  fetch aggregated fields from the table: "external_systems"
  """
  external_systems_aggregate(
    """distinct select on columns"""
    distinct_on: [external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_systems_order_by!]

    """filter the rows returned"""
    where: external_systems_bool_exp
  ): external_systems_aggregate!

  """
  fetch data from the table: "external_systems" using primary key columns
  """
  external_systems_by_pk(
    """Unique identifier for the external system"""
    id: uuid!
  ): external_systems

  """
  fetch data from the table in a streaming manner: "external_systems"
  """
  external_systems_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [external_systems_stream_cursor_input]!

    """filter the rows returned"""
    where: external_systems_bool_exp
  ): [external_systems!]!

  """
  fetch data from the table: "feature_flags"
  """
  feature_flags(
    """distinct select on columns"""
    distinct_on: [feature_flags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_flags_order_by!]

    """filter the rows returned"""
    where: feature_flags_bool_exp
  ): [feature_flags!]!

  """
  fetch aggregated fields from the table: "feature_flags"
  """
  feature_flags_aggregate(
    """distinct select on columns"""
    distinct_on: [feature_flags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_flags_order_by!]

    """filter the rows returned"""
    where: feature_flags_bool_exp
  ): feature_flags_aggregate!

  """fetch data from the table: "feature_flags" using primary key columns"""
  feature_flags_by_pk(
    """Unique identifier for the feature flag"""
    id: uuid!
  ): feature_flags

  """
  fetch data from the table in a streaming manner: "feature_flags"
  """
  feature_flags_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [feature_flags_stream_cursor_input]!

    """filter the rows returned"""
    where: feature_flags_bool_exp
  ): [feature_flags!]!

  """
  execute function "generate_payroll_dates" which returns "payroll_dates"
  """
  generate_payroll_dates(
    """
    input parameters for function "generate_payroll_dates"
    """
    args: generate_payroll_dates_args!

    """distinct select on columns"""
    distinct_on: [payroll_dates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_dates_order_by!]

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): [payroll_dates!]!

  """
  execute function "generate_payroll_dates" and query aggregates on result of table type "payroll_dates"
  """
  generate_payroll_dates_aggregate(
    """
    input parameters for function "generate_payroll_dates_aggregate"
    """
    args: generate_payroll_dates_args!

    """distinct select on columns"""
    distinct_on: [payroll_dates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_dates_order_by!]

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): payroll_dates_aggregate!

  """
  fetch data from the table: "holidays"
  """
  holidays(
    """distinct select on columns"""
    distinct_on: [holidays_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [holidays_order_by!]

    """filter the rows returned"""
    where: holidays_bool_exp
  ): [holidays!]!

  """
  fetch aggregated fields from the table: "holidays"
  """
  holidays_aggregate(
    """distinct select on columns"""
    distinct_on: [holidays_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [holidays_order_by!]

    """filter the rows returned"""
    where: holidays_bool_exp
  ): holidays_aggregate!

  """fetch data from the table: "holidays" using primary key columns"""
  holidays_by_pk(
    """Unique identifier for the holiday"""
    id: uuid!
  ): holidays

  """
  fetch data from the table in a streaming manner: "holidays"
  """
  holidays_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [holidays_stream_cursor_input]!

    """filter the rows returned"""
    where: holidays_bool_exp
  ): [holidays!]!

  """
  fetch data from the table: "leave"
  """
  leave(
    """distinct select on columns"""
    distinct_on: [leave_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_order_by!]

    """filter the rows returned"""
    where: leave_bool_exp
  ): [leave!]!

  """
  fetch aggregated fields from the table: "leave"
  """
  leave_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_order_by!]

    """filter the rows returned"""
    where: leave_bool_exp
  ): leave_aggregate!

  """fetch data from the table: "leave" using primary key columns"""
  leave_by_pk(
    """Unique identifier for the leave record"""
    id: uuid!
  ): leave

  """
  fetch data from the table in a streaming manner: "leave"
  """
  leave_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [leave_stream_cursor_input]!

    """filter the rows returned"""
    where: leave_bool_exp
  ): [leave!]!

  """
  fetch data from the table: "neon_auth.users_sync"
  """
  neon_auth_users_sync(
    """distinct select on columns"""
    distinct_on: [neon_auth_users_sync_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neon_auth_users_sync_order_by!]

    """filter the rows returned"""
    where: neon_auth_users_sync_bool_exp
  ): [neon_auth_users_sync!]!

  """
  fetch aggregated fields from the table: "neon_auth.users_sync"
  """
  neon_auth_users_sync_aggregate(
    """distinct select on columns"""
    distinct_on: [neon_auth_users_sync_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neon_auth_users_sync_order_by!]

    """filter the rows returned"""
    where: neon_auth_users_sync_bool_exp
  ): neon_auth_users_sync_aggregate!

  """
  fetch data from the table: "neon_auth.users_sync" using primary key columns
  """
  neon_auth_users_sync_by_pk(
    """Unique identifier from the authentication provider"""
    id: String!
  ): neon_auth_users_sync

  """
  fetch data from the table in a streaming manner: "neon_auth.users_sync"
  """
  neon_auth_users_sync_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [neon_auth_users_sync_stream_cursor_input]!

    """filter the rows returned"""
    where: neon_auth_users_sync_bool_exp
  ): [neon_auth_users_sync!]!

  """
  fetch data from the table: "notes"
  """
  notes(
    """distinct select on columns"""
    distinct_on: [notes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_order_by!]

    """filter the rows returned"""
    where: notes_bool_exp
  ): [notes!]!

  """
  fetch aggregated fields from the table: "notes"
  """
  notes_aggregate(
    """distinct select on columns"""
    distinct_on: [notes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_order_by!]

    """filter the rows returned"""
    where: notes_bool_exp
  ): notes_aggregate!

  """fetch data from the table: "notes" using primary key columns"""
  notes_by_pk(
    """Unique identifier for the note"""
    id: uuid!
  ): notes

  """
  fetch data from the table in a streaming manner: "notes"
  """
  notes_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notes_stream_cursor_input]!

    """filter the rows returned"""
    where: notes_bool_exp
  ): [notes!]!

  """
  fetch data from the table: "payroll_cycles"
  """
  payroll_cycles(
    """distinct select on columns"""
    distinct_on: [payroll_cycles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_cycles_order_by!]

    """filter the rows returned"""
    where: payroll_cycles_bool_exp
  ): [payroll_cycles!]!

  """
  fetch aggregated fields from the table: "payroll_cycles"
  """
  payroll_cycles_aggregate(
    """distinct select on columns"""
    distinct_on: [payroll_cycles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_cycles_order_by!]

    """filter the rows returned"""
    where: payroll_cycles_bool_exp
  ): payroll_cycles_aggregate!

  """fetch data from the table: "payroll_cycles" using primary key columns"""
  payroll_cycles_by_pk(
    """Unique identifier for the payroll cycle"""
    id: uuid!
  ): payroll_cycles

  """
  fetch data from the table in a streaming manner: "payroll_cycles"
  """
  payroll_cycles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payroll_cycles_stream_cursor_input]!

    """filter the rows returned"""
    where: payroll_cycles_bool_exp
  ): [payroll_cycles!]!

  """
  fetch data from the table: "payroll_date_types"
  """
  payroll_date_types(
    """distinct select on columns"""
    distinct_on: [payroll_date_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_date_types_order_by!]

    """filter the rows returned"""
    where: payroll_date_types_bool_exp
  ): [payroll_date_types!]!

  """
  fetch aggregated fields from the table: "payroll_date_types"
  """
  payroll_date_types_aggregate(
    """distinct select on columns"""
    distinct_on: [payroll_date_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_date_types_order_by!]

    """filter the rows returned"""
    where: payroll_date_types_bool_exp
  ): payroll_date_types_aggregate!

  """
  fetch data from the table: "payroll_date_types" using primary key columns
  """
  payroll_date_types_by_pk(
    """Unique identifier for the payroll date type"""
    id: uuid!
  ): payroll_date_types

  """
  fetch data from the table in a streaming manner: "payroll_date_types"
  """
  payroll_date_types_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payroll_date_types_stream_cursor_input]!

    """filter the rows returned"""
    where: payroll_date_types_bool_exp
  ): [payroll_date_types!]!

  """An array relationship"""
  payroll_dates(
    """distinct select on columns"""
    distinct_on: [payroll_dates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_dates_order_by!]

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): [payroll_dates!]!

  """An aggregate relationship"""
  payroll_dates_aggregate(
    """distinct select on columns"""
    distinct_on: [payroll_dates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_dates_order_by!]

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): payroll_dates_aggregate!

  """fetch data from the table: "payroll_dates" using primary key columns"""
  payroll_dates_by_pk(
    """Unique identifier for the payroll date"""
    id: uuid!
  ): payroll_dates

  """
  fetch data from the table in a streaming manner: "payroll_dates"
  """
  payroll_dates_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payroll_dates_stream_cursor_input]!

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): [payroll_dates!]!

  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """An aggregate relationship"""
  payrolls_aggregate(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): payrolls_aggregate!

  """fetch data from the table: "payrolls" using primary key columns"""
  payrolls_by_pk(
    """Unique identifier for the payroll"""
    id: uuid!
  ): payrolls

  """
  fetch data from the table in a streaming manner: "payrolls"
  """
  payrolls_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payrolls_stream_cursor_input]!

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """
  fetch data from the table: "permission_audit_log"
  """
  permission_audit_log(
    """distinct select on columns"""
    distinct_on: [permission_audit_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_audit_log_order_by!]

    """filter the rows returned"""
    where: permission_audit_log_bool_exp
  ): [permission_audit_log!]!

  """
  fetch aggregated fields from the table: "permission_audit_log"
  """
  permission_audit_log_aggregate(
    """distinct select on columns"""
    distinct_on: [permission_audit_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_audit_log_order_by!]

    """filter the rows returned"""
    where: permission_audit_log_bool_exp
  ): permission_audit_log_aggregate!

  """
  fetch data from the table: "permission_audit_log" using primary key columns
  """
  permission_audit_log_by_pk(
    """Unique identifier for the audit log entry"""
    id: uuid!
  ): permission_audit_log

  """
  fetch data from the table in a streaming manner: "permission_audit_log"
  """
  permission_audit_log_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [permission_audit_log_stream_cursor_input]!

    """filter the rows returned"""
    where: permission_audit_log_bool_exp
  ): [permission_audit_log!]!

  """
  fetch data from the table: "permission_overrides"
  """
  permission_overrides(
    """distinct select on columns"""
    distinct_on: [permission_overrides_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_overrides_order_by!]

    """filter the rows returned"""
    where: permission_overrides_bool_exp
  ): [permission_overrides!]!

  """
  fetch aggregated fields from the table: "permission_overrides"
  """
  permission_overrides_aggregate(
    """distinct select on columns"""
    distinct_on: [permission_overrides_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_overrides_order_by!]

    """filter the rows returned"""
    where: permission_overrides_bool_exp
  ): permission_overrides_aggregate!

  """
  fetch data from the table: "permission_overrides" using primary key columns
  """
  permission_overrides_by_pk(
    """Unique identifier for the permission override"""
    id: uuid!
  ): permission_overrides

  """
  fetch data from the table in a streaming manner: "permission_overrides"
  """
  permission_overrides_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [permission_overrides_stream_cursor_input]!

    """filter the rows returned"""
    where: permission_overrides_bool_exp
  ): [permission_overrides!]!

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(
    """Unique identifier for the user"""
    id: uuid!
  ): users

  """
  fetch data from the table in a streaming manner: "users"
  """
  users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [users_stream_cursor_input]!

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch data from the table: "work_schedule"
  """
  work_schedule(
    """distinct select on columns"""
    distinct_on: [work_schedule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [work_schedule_order_by!]

    """filter the rows returned"""
    where: work_schedule_bool_exp
  ): [work_schedule!]!

  """
  fetch aggregated fields from the table: "work_schedule"
  """
  work_schedule_aggregate(
    """distinct select on columns"""
    distinct_on: [work_schedule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [work_schedule_order_by!]

    """filter the rows returned"""
    where: work_schedule_bool_exp
  ): work_schedule_aggregate!

  """fetch data from the table: "work_schedule" using primary key columns"""
  work_schedule_by_pk(
    """Unique identifier for the work schedule entry"""
    id: uuid!
  ): work_schedule

  """
  fetch data from the table in a streaming manner: "work_schedule"
  """
  work_schedule_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [work_schedule_stream_cursor_input]!

    """filter the rows returned"""
    where: work_schedule_bool_exp
  ): [work_schedule!]!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

scalar user_role

"""
Boolean expression to compare columns of type "user_role". All fields are combined with logical 'AND'.
"""
input user_role_comparison_exp {
  _eq: user_role
  _gt: user_role
  _gte: user_role
  _in: [user_role!]
  _is_null: Boolean
  _lt: user_role
  _lte: user_role
  _neq: user_role
  _nin: [user_role!]
}

"""
columns and relationships of "users"
"""
type users {
  """An array relationship"""
  audit_logs_performed(
    """distinct select on columns"""
    distinct_on: [permission_audit_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_audit_log_order_by!]

    """filter the rows returned"""
    where: permission_audit_log_bool_exp
  ): [permission_audit_log!]!

  """An aggregate relationship"""
  audit_logs_performed_aggregate(
    """distinct select on columns"""
    distinct_on: [permission_audit_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_audit_log_order_by!]

    """filter the rows returned"""
    where: permission_audit_log_bool_exp
  ): permission_audit_log_aggregate!

  """An array relationship"""
  audit_logs_targeted(
    """distinct select on columns"""
    distinct_on: [permission_audit_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_audit_log_order_by!]

    """filter the rows returned"""
    where: permission_audit_log_bool_exp
  ): [permission_audit_log!]!

  """An aggregate relationship"""
  audit_logs_targeted_aggregate(
    """distinct select on columns"""
    distinct_on: [permission_audit_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_audit_log_order_by!]

    """filter the rows returned"""
    where: permission_audit_log_bool_exp
  ): permission_audit_log_aggregate!

  """External identifier from Clerk authentication service"""
  clerk_user_id: String

  """Timestamp when the user was created"""
  created_at: timestamptz

  """User's email address (unique)"""
  email: String!

  """Unique identifier for the user"""
  id: uuid!

  """URL to the user's profile image"""
  image: String

  """Whether the user is a staff member (vs. external user)"""
  is_staff: Boolean

  """An array relationship"""
  leaves(
    """distinct select on columns"""
    distinct_on: [leave_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_order_by!]

    """filter the rows returned"""
    where: leave_bool_exp
  ): [leave!]!

  """An aggregate relationship"""
  leaves_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_order_by!]

    """filter the rows returned"""
    where: leave_bool_exp
  ): leave_aggregate!

  """An object relationship"""
  manager: users

  """Reference to the user's manager"""
  manager_id: uuid

  """User's full name"""
  name: String!

  """An array relationship"""
  notes_written(
    """distinct select on columns"""
    distinct_on: [notes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_order_by!]

    """filter the rows returned"""
    where: notes_bool_exp
  ): [notes!]!

  """An aggregate relationship"""
  notes_written_aggregate(
    """distinct select on columns"""
    distinct_on: [notes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_order_by!]

    """filter the rows returned"""
    where: notes_bool_exp
  ): notes_aggregate!

  """An array relationship"""
  overrides_assigned(
    """distinct select on columns"""
    distinct_on: [permission_overrides_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_overrides_order_by!]

    """filter the rows returned"""
    where: permission_overrides_bool_exp
  ): [permission_overrides!]!

  """An aggregate relationship"""
  overrides_assigned_aggregate(
    """distinct select on columns"""
    distinct_on: [permission_overrides_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_overrides_order_by!]

    """filter the rows returned"""
    where: permission_overrides_bool_exp
  ): permission_overrides_aggregate!

  """An array relationship"""
  overrides_created(
    """distinct select on columns"""
    distinct_on: [permission_overrides_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_overrides_order_by!]

    """filter the rows returned"""
    where: permission_overrides_bool_exp
  ): [permission_overrides!]!

  """An aggregate relationship"""
  overrides_created_aggregate(
    """distinct select on columns"""
    distinct_on: [permission_overrides_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_overrides_order_by!]

    """filter the rows returned"""
    where: permission_overrides_bool_exp
  ): permission_overrides_aggregate!

  """An array relationship"""
  payrollsByBackupConsultantUserId(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """An aggregate relationship"""
  payrollsByBackupConsultantUserId_aggregate(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): payrolls_aggregate!

  """An array relationship"""
  payrollsByManagerUserId(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """An aggregate relationship"""
  payrollsByManagerUserId_aggregate(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): payrolls_aggregate!

  """An array relationship"""
  payrollsByPrimaryConsultantUserId(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """An aggregate relationship"""
  payrollsByPrimaryConsultantUserId_aggregate(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): payrolls_aggregate!

  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role!

  """An array relationship"""
  staffByManager(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  staffByManager_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """Timestamp when the user was last updated"""
  updated_at: timestamptz

  """User's unique username for login"""
  username: String

  """An array relationship"""
  usersManager(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  usersManager_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """An array relationship"""
  work_schedules(
    """distinct select on columns"""
    distinct_on: [work_schedule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [work_schedule_order_by!]

    """filter the rows returned"""
    where: work_schedule_bool_exp
  ): [work_schedule!]!

  """An aggregate relationship"""
  work_schedules_aggregate(
    """distinct select on columns"""
    distinct_on: [work_schedule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [work_schedule_order_by!]

    """filter the rows returned"""
    where: work_schedule_bool_exp
  ): work_schedule_aggregate!
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

input users_aggregate_bool_exp {
  bool_and: users_aggregate_bool_exp_bool_and
  bool_or: users_aggregate_bool_exp_bool_or
  count: users_aggregate_bool_exp_count
}

input users_aggregate_bool_exp_bool_and {
  arguments: users_select_column_users_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: users_bool_exp
  predicate: Boolean_comparison_exp!
}

input users_aggregate_bool_exp_bool_or {
  arguments: users_select_column_users_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: users_bool_exp
  predicate: Boolean_comparison_exp!
}

input users_aggregate_bool_exp_count {
  arguments: [users_select_column!]
  distinct: Boolean
  filter: users_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
}

"""
order by aggregate values of table "users"
"""
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

"""
input type for inserting array relation for remote table "users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  audit_logs_performed: permission_audit_log_bool_exp
  audit_logs_performed_aggregate: permission_audit_log_aggregate_bool_exp
  audit_logs_targeted: permission_audit_log_bool_exp
  audit_logs_targeted_aggregate: permission_audit_log_aggregate_bool_exp
  clerk_user_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  image: String_comparison_exp
  is_staff: Boolean_comparison_exp
  leaves: leave_bool_exp
  leaves_aggregate: leave_aggregate_bool_exp
  manager: users_bool_exp
  manager_id: uuid_comparison_exp
  name: String_comparison_exp
  notes_written: notes_bool_exp
  notes_written_aggregate: notes_aggregate_bool_exp
  overrides_assigned: permission_overrides_bool_exp
  overrides_assigned_aggregate: permission_overrides_aggregate_bool_exp
  overrides_created: permission_overrides_bool_exp
  overrides_created_aggregate: permission_overrides_aggregate_bool_exp
  payrollsByBackupConsultantUserId: payrolls_bool_exp
  payrollsByBackupConsultantUserId_aggregate: payrolls_aggregate_bool_exp
  payrollsByManagerUserId: payrolls_bool_exp
  payrollsByManagerUserId_aggregate: payrolls_aggregate_bool_exp
  payrollsByPrimaryConsultantUserId: payrolls_bool_exp
  payrollsByPrimaryConsultantUserId_aggregate: payrolls_aggregate_bool_exp
  role: user_role_comparison_exp
  staffByManager: users_bool_exp
  staffByManager_aggregate: users_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
  username: String_comparison_exp
  usersManager: users_bool_exp
  usersManager_aggregate: users_aggregate_bool_exp
  work_schedules: work_schedule_bool_exp
  work_schedules_aggregate: work_schedule_aggregate_bool_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """
  unique or primary key constraint on columns "clerk_user_id"
  """
  users_clerk_user_id_key

  """
  unique or primary key constraint on columns "email"
  """
  users_email_key

  """
  unique or primary key constraint on columns "id"
  """
  users_pkey

  """
  unique or primary key constraint on columns "username"
  """
  users_username_key
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  audit_logs_performed: permission_audit_log_arr_rel_insert_input
  audit_logs_targeted: permission_audit_log_arr_rel_insert_input

  """External identifier from Clerk authentication service"""
  clerk_user_id: String

  """Timestamp when the user was created"""
  created_at: timestamptz

  """User's email address (unique)"""
  email: String

  """Unique identifier for the user"""
  id: uuid

  """URL to the user's profile image"""
  image: String

  """Whether the user is a staff member (vs. external user)"""
  is_staff: Boolean
  leaves: leave_arr_rel_insert_input
  manager: users_obj_rel_insert_input

  """Reference to the user's manager"""
  manager_id: uuid

  """User's full name"""
  name: String
  notes_written: notes_arr_rel_insert_input
  overrides_assigned: permission_overrides_arr_rel_insert_input
  overrides_created: permission_overrides_arr_rel_insert_input
  payrollsByBackupConsultantUserId: payrolls_arr_rel_insert_input
  payrollsByManagerUserId: payrolls_arr_rel_insert_input
  payrollsByPrimaryConsultantUserId: payrolls_arr_rel_insert_input

  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role
  staffByManager: users_arr_rel_insert_input

  """Timestamp when the user was last updated"""
  updated_at: timestamptz

  """User's unique username for login"""
  username: String
  usersManager: users_arr_rel_insert_input
  work_schedules: work_schedule_arr_rel_insert_input
}

"""aggregate max on columns"""
type users_max_fields {
  """External identifier from Clerk authentication service"""
  clerk_user_id: String

  """Timestamp when the user was created"""
  created_at: timestamptz

  """User's email address (unique)"""
  email: String

  """Unique identifier for the user"""
  id: uuid

  """URL to the user's profile image"""
  image: String

  """Reference to the user's manager"""
  manager_id: uuid

  """User's full name"""
  name: String

  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role

  """Timestamp when the user was last updated"""
  updated_at: timestamptz

  """User's unique username for login"""
  username: String
}

"""
order by max() on columns of table "users"
"""
input users_max_order_by {
  """External identifier from Clerk authentication service"""
  clerk_user_id: order_by

  """Timestamp when the user was created"""
  created_at: order_by

  """User's email address (unique)"""
  email: order_by

  """Unique identifier for the user"""
  id: order_by

  """URL to the user's profile image"""
  image: order_by

  """Reference to the user's manager"""
  manager_id: order_by

  """User's full name"""
  name: order_by

  """User's system role (viewer, consultant, manager, org_admin)"""
  role: order_by

  """Timestamp when the user was last updated"""
  updated_at: order_by

  """User's unique username for login"""
  username: order_by
}

"""aggregate min on columns"""
type users_min_fields {
  """External identifier from Clerk authentication service"""
  clerk_user_id: String

  """Timestamp when the user was created"""
  created_at: timestamptz

  """User's email address (unique)"""
  email: String

  """Unique identifier for the user"""
  id: uuid

  """URL to the user's profile image"""
  image: String

  """Reference to the user's manager"""
  manager_id: uuid

  """User's full name"""
  name: String

  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role

  """Timestamp when the user was last updated"""
  updated_at: timestamptz

  """User's unique username for login"""
  username: String
}

"""
order by min() on columns of table "users"
"""
input users_min_order_by {
  """External identifier from Clerk authentication service"""
  clerk_user_id: order_by

  """Timestamp when the user was created"""
  created_at: order_by

  """User's email address (unique)"""
  email: order_by

  """Unique identifier for the user"""
  id: order_by

  """URL to the user's profile image"""
  image: order_by

  """Reference to the user's manager"""
  manager_id: order_by

  """User's full name"""
  name: order_by

  """User's system role (viewer, consultant, manager, org_admin)"""
  role: order_by

  """Timestamp when the user was last updated"""
  updated_at: order_by

  """User's unique username for login"""
  username: order_by
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
on_conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"""Ordering options when selecting data from "users"."""
input users_order_by {
  audit_logs_performed_aggregate: permission_audit_log_aggregate_order_by
  audit_logs_targeted_aggregate: permission_audit_log_aggregate_order_by
  clerk_user_id: order_by
  created_at: order_by
  email: order_by
  id: order_by
  image: order_by
  is_staff: order_by
  leaves_aggregate: leave_aggregate_order_by
  manager: users_order_by
  manager_id: order_by
  name: order_by
  notes_written_aggregate: notes_aggregate_order_by
  overrides_assigned_aggregate: permission_overrides_aggregate_order_by
  overrides_created_aggregate: permission_overrides_aggregate_order_by
  payrollsByBackupConsultantUserId_aggregate: payrolls_aggregate_order_by
  payrollsByManagerUserId_aggregate: payrolls_aggregate_order_by
  payrollsByPrimaryConsultantUserId_aggregate: payrolls_aggregate_order_by
  role: order_by
  staffByManager_aggregate: users_aggregate_order_by
  updated_at: order_by
  username: order_by
  usersManager_aggregate: users_aggregate_order_by
  work_schedules_aggregate: work_schedule_aggregate_order_by
}

"""primary key columns input for table: users"""
input users_pk_columns_input {
  """Unique identifier for the user"""
  id: uuid!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """column name"""
  clerk_user_id

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  image

  """column name"""
  is_staff

  """column name"""
  manager_id

  """column name"""
  name

  """column name"""
  role

  """column name"""
  updated_at

  """column name"""
  username
}

"""
select "users_aggregate_bool_exp_bool_and_arguments_columns" columns of table "users"
"""
enum users_select_column_users_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_staff
}

"""
select "users_aggregate_bool_exp_bool_or_arguments_columns" columns of table "users"
"""
enum users_select_column_users_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_staff
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  """External identifier from Clerk authentication service"""
  clerk_user_id: String

  """Timestamp when the user was created"""
  created_at: timestamptz

  """User's email address (unique)"""
  email: String

  """Unique identifier for the user"""
  id: uuid

  """URL to the user's profile image"""
  image: String

  """Whether the user is a staff member (vs. external user)"""
  is_staff: Boolean

  """Reference to the user's manager"""
  manager_id: uuid

  """User's full name"""
  name: String

  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role

  """Timestamp when the user was last updated"""
  updated_at: timestamptz

  """User's unique username for login"""
  username: String
}

"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input users_stream_cursor_value_input {
  """External identifier from Clerk authentication service"""
  clerk_user_id: String

  """Timestamp when the user was created"""
  created_at: timestamptz

  """User's email address (unique)"""
  email: String

  """Unique identifier for the user"""
  id: uuid

  """URL to the user's profile image"""
  image: String

  """Whether the user is a staff member (vs. external user)"""
  is_staff: Boolean

  """Reference to the user's manager"""
  manager_id: uuid

  """User's full name"""
  name: String

  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role

  """Timestamp when the user was last updated"""
  updated_at: timestamptz

  """User's unique username for login"""
  username: String
}

"""
update columns of table "users"
"""
enum users_update_column {
  """column name"""
  clerk_user_id

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  image

  """column name"""
  is_staff

  """column name"""
  manager_id

  """column name"""
  name

  """column name"""
  role

  """column name"""
  updated_at

  """column name"""
  username
}

input users_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: users_set_input

  """filter the rows which have to be updated"""
  where: users_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "work_schedule"
"""
type work_schedule {
  """Timestamp when the schedule entry was created"""
  created_at: timestamp

  """Unique identifier for the work schedule entry"""
  id: uuid!

  """Timestamp when the schedule entry was last updated"""
  updated_at: timestamp

  """An object relationship"""
  user: users!

  """Reference to the user this schedule belongs to"""
  user_id: uuid!

  """Day of the week (Monday, Tuesday, etc.)"""
  work_day: String!

  """Number of hours worked on this day"""
  work_hours: numeric!

  """An object relationship"""
  work_schedule_user: users!
}

"""
aggregated selection of "work_schedule"
"""
type work_schedule_aggregate {
  aggregate: work_schedule_aggregate_fields
  nodes: [work_schedule!]!
}

input work_schedule_aggregate_bool_exp {
  count: work_schedule_aggregate_bool_exp_count
}

input work_schedule_aggregate_bool_exp_count {
  arguments: [work_schedule_select_column!]
  distinct: Boolean
  filter: work_schedule_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "work_schedule"
"""
type work_schedule_aggregate_fields {
  avg: work_schedule_avg_fields
  count(columns: [work_schedule_select_column!], distinct: Boolean): Int!
  max: work_schedule_max_fields
  min: work_schedule_min_fields
  stddev: work_schedule_stddev_fields
  stddev_pop: work_schedule_stddev_pop_fields
  stddev_samp: work_schedule_stddev_samp_fields
  sum: work_schedule_sum_fields
  var_pop: work_schedule_var_pop_fields
  var_samp: work_schedule_var_samp_fields
  variance: work_schedule_variance_fields
}

"""
order by aggregate values of table "work_schedule"
"""
input work_schedule_aggregate_order_by {
  avg: work_schedule_avg_order_by
  count: order_by
  max: work_schedule_max_order_by
  min: work_schedule_min_order_by
  stddev: work_schedule_stddev_order_by
  stddev_pop: work_schedule_stddev_pop_order_by
  stddev_samp: work_schedule_stddev_samp_order_by
  sum: work_schedule_sum_order_by
  var_pop: work_schedule_var_pop_order_by
  var_samp: work_schedule_var_samp_order_by
  variance: work_schedule_variance_order_by
}

"""
input type for inserting array relation for remote table "work_schedule"
"""
input work_schedule_arr_rel_insert_input {
  data: [work_schedule_insert_input!]!

  """upsert condition"""
  on_conflict: work_schedule_on_conflict
}

"""aggregate avg on columns"""
type work_schedule_avg_fields {
  """Number of hours worked on this day"""
  work_hours: Float
}

"""
order by avg() on columns of table "work_schedule"
"""
input work_schedule_avg_order_by {
  """Number of hours worked on this day"""
  work_hours: order_by
}

"""
Boolean expression to filter rows from the table "work_schedule". All fields are combined with a logical 'AND'.
"""
input work_schedule_bool_exp {
  _and: [work_schedule_bool_exp!]
  _not: work_schedule_bool_exp
  _or: [work_schedule_bool_exp!]
  created_at: timestamp_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamp_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
  work_day: String_comparison_exp
  work_hours: numeric_comparison_exp
  work_schedule_user: users_bool_exp
}

"""
unique or primary key constraints on table "work_schedule"
"""
enum work_schedule_constraint {
  """
  unique or primary key constraint on columns "user_id", "work_day"
  """
  unique_user_work_day

  """
  unique or primary key constraint on columns "id"
  """
  work_schedule_pkey
}

"""
input type for incrementing numeric columns in table "work_schedule"
"""
input work_schedule_inc_input {
  """Number of hours worked on this day"""
  work_hours: numeric
}

"""
input type for inserting data into table "work_schedule"
"""
input work_schedule_insert_input {
  """Timestamp when the schedule entry was created"""
  created_at: timestamp

  """Unique identifier for the work schedule entry"""
  id: uuid

  """Timestamp when the schedule entry was last updated"""
  updated_at: timestamp
  user: users_obj_rel_insert_input

  """Reference to the user this schedule belongs to"""
  user_id: uuid

  """Day of the week (Monday, Tuesday, etc.)"""
  work_day: String

  """Number of hours worked on this day"""
  work_hours: numeric
  work_schedule_user: users_obj_rel_insert_input
}

"""aggregate max on columns"""
type work_schedule_max_fields {
  """Timestamp when the schedule entry was created"""
  created_at: timestamp

  """Unique identifier for the work schedule entry"""
  id: uuid

  """Timestamp when the schedule entry was last updated"""
  updated_at: timestamp

  """Reference to the user this schedule belongs to"""
  user_id: uuid

  """Day of the week (Monday, Tuesday, etc.)"""
  work_day: String

  """Number of hours worked on this day"""
  work_hours: numeric
}

"""
order by max() on columns of table "work_schedule"
"""
input work_schedule_max_order_by {
  """Timestamp when the schedule entry was created"""
  created_at: order_by

  """Unique identifier for the work schedule entry"""
  id: order_by

  """Timestamp when the schedule entry was last updated"""
  updated_at: order_by

  """Reference to the user this schedule belongs to"""
  user_id: order_by

  """Day of the week (Monday, Tuesday, etc.)"""
  work_day: order_by

  """Number of hours worked on this day"""
  work_hours: order_by
}

"""aggregate min on columns"""
type work_schedule_min_fields {
  """Timestamp when the schedule entry was created"""
  created_at: timestamp

  """Unique identifier for the work schedule entry"""
  id: uuid

  """Timestamp when the schedule entry was last updated"""
  updated_at: timestamp

  """Reference to the user this schedule belongs to"""
  user_id: uuid

  """Day of the week (Monday, Tuesday, etc.)"""
  work_day: String

  """Number of hours worked on this day"""
  work_hours: numeric
}

"""
order by min() on columns of table "work_schedule"
"""
input work_schedule_min_order_by {
  """Timestamp when the schedule entry was created"""
  created_at: order_by

  """Unique identifier for the work schedule entry"""
  id: order_by

  """Timestamp when the schedule entry was last updated"""
  updated_at: order_by

  """Reference to the user this schedule belongs to"""
  user_id: order_by

  """Day of the week (Monday, Tuesday, etc.)"""
  work_day: order_by

  """Number of hours worked on this day"""
  work_hours: order_by
}

"""
response of any mutation on the table "work_schedule"
"""
type work_schedule_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [work_schedule!]!
}

"""
on_conflict condition type for table "work_schedule"
"""
input work_schedule_on_conflict {
  constraint: work_schedule_constraint!
  update_columns: [work_schedule_update_column!]! = []
  where: work_schedule_bool_exp
}

"""Ordering options when selecting data from "work_schedule"."""
input work_schedule_order_by {
  created_at: order_by
  id: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
  work_day: order_by
  work_hours: order_by
  work_schedule_user: users_order_by
}

"""primary key columns input for table: work_schedule"""
input work_schedule_pk_columns_input {
  """Unique identifier for the work schedule entry"""
  id: uuid!
}

"""
select columns of table "work_schedule"
"""
enum work_schedule_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  work_day

  """column name"""
  work_hours
}

"""
input type for updating data in table "work_schedule"
"""
input work_schedule_set_input {
  """Timestamp when the schedule entry was created"""
  created_at: timestamp

  """Unique identifier for the work schedule entry"""
  id: uuid

  """Timestamp when the schedule entry was last updated"""
  updated_at: timestamp

  """Reference to the user this schedule belongs to"""
  user_id: uuid

  """Day of the week (Monday, Tuesday, etc.)"""
  work_day: String

  """Number of hours worked on this day"""
  work_hours: numeric
}

"""aggregate stddev on columns"""
type work_schedule_stddev_fields {
  """Number of hours worked on this day"""
  work_hours: Float
}

"""
order by stddev() on columns of table "work_schedule"
"""
input work_schedule_stddev_order_by {
  """Number of hours worked on this day"""
  work_hours: order_by
}

"""aggregate stddev_pop on columns"""
type work_schedule_stddev_pop_fields {
  """Number of hours worked on this day"""
  work_hours: Float
}

"""
order by stddev_pop() on columns of table "work_schedule"
"""
input work_schedule_stddev_pop_order_by {
  """Number of hours worked on this day"""
  work_hours: order_by
}

"""aggregate stddev_samp on columns"""
type work_schedule_stddev_samp_fields {
  """Number of hours worked on this day"""
  work_hours: Float
}

"""
order by stddev_samp() on columns of table "work_schedule"
"""
input work_schedule_stddev_samp_order_by {
  """Number of hours worked on this day"""
  work_hours: order_by
}

"""
Streaming cursor of the table "work_schedule"
"""
input work_schedule_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: work_schedule_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input work_schedule_stream_cursor_value_input {
  """Timestamp when the schedule entry was created"""
  created_at: timestamp

  """Unique identifier for the work schedule entry"""
  id: uuid

  """Timestamp when the schedule entry was last updated"""
  updated_at: timestamp

  """Reference to the user this schedule belongs to"""
  user_id: uuid

  """Day of the week (Monday, Tuesday, etc.)"""
  work_day: String

  """Number of hours worked on this day"""
  work_hours: numeric
}

"""aggregate sum on columns"""
type work_schedule_sum_fields {
  """Number of hours worked on this day"""
  work_hours: numeric
}

"""
order by sum() on columns of table "work_schedule"
"""
input work_schedule_sum_order_by {
  """Number of hours worked on this day"""
  work_hours: order_by
}

"""
update columns of table "work_schedule"
"""
enum work_schedule_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  work_day

  """column name"""
  work_hours
}

input work_schedule_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: work_schedule_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: work_schedule_set_input

  """filter the rows which have to be updated"""
  where: work_schedule_bool_exp!
}

"""aggregate var_pop on columns"""
type work_schedule_var_pop_fields {
  """Number of hours worked on this day"""
  work_hours: Float
}

"""
order by var_pop() on columns of table "work_schedule"
"""
input work_schedule_var_pop_order_by {
  """Number of hours worked on this day"""
  work_hours: order_by
}

"""aggregate var_samp on columns"""
type work_schedule_var_samp_fields {
  """Number of hours worked on this day"""
  work_hours: Float
}

"""
order by var_samp() on columns of table "work_schedule"
"""
input work_schedule_var_samp_order_by {
  """Number of hours worked on this day"""
  work_hours: order_by
}

"""aggregate variance on columns"""
type work_schedule_variance_fields {
  """Number of hours worked on this day"""
  work_hours: Float
}

"""
order by variance() on columns of table "work_schedule"
"""
input work_schedule_variance_order_by {
  """Number of hours worked on this day"""
  work_hours: order_by
}